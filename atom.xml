<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱吃鸭梨的猫</title>
  
  <subtitle>创造财富 才是时间最正确的归宿</subtitle>
  <link href="https://karise.cn/atom.xml" rel="self"/>
  
  <link href="https://karise.cn/"/>
  <updated>2023-02-28T03:19:29.345Z</updated>
  <id>https://karise.cn/</id>
  
  <author>
    <name>爱吃鸭梨的猫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>给 mac 手工安装 Windows 以解决 BootCamp 方式安装失败的问题</title>
    <link href="https://karise.cn/2023/02/28/Mac/202302281100/"/>
    <id>https://karise.cn/2023/02/28/Mac/202302281100/</id>
    <published>2023-02-28T03:03:00.000Z</published>
    <updated>2023-02-28T03:19:29.345Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我的 MacBook Pro 2015 使用BootCamp能够正常安装 Win 10，但是我的 Mac Mini 2018 使用BootCamp安装 Win 10 的时候，重启就黑屏，怎么也加载不出 Windows 安装程序，重装 Mac 系统等各种方法都试过了，就是不行，所以无奈只能寻找手工安装 Windows 的方式，这是 <a href="https://plusnan.me/2018/12/14/install-windows-on-macbook-pro-2018/">参考文章</a> 。</p></blockquote><blockquote><p>实际上大多数 ISO 系统是可以借助 Boot Camp 安装的，可以去 <a href="https://msdn.itellyou.cn/">MSDN I Tell You</a> 多试几个版本，总有一个能用的，如果版本比较老，装好之后再去 Windows Update 里头做个升级就行了。</p></blockquote><a id="more"></a><h2 id="BootCamp-其他的坑"><a href="#BootCamp-其他的坑" class="headerlink" title="BootCamp 其他的坑"></a>BootCamp 其他的坑</h2><ul><li>用 Boot Camp 创建启动盘时会提示 “启动转换安装失败”、“拷贝 Windows 安装文件时出错”、“启动转换助理正在移除其创建的分区，请稍候”，因为 Windows 10 安装盘通常大于 4GB，FAT32 格式分区装不下，所以失败。</li><li>即使找到了小于 4GB 的安装盘，也不要继续用 Boot Camp 来进行安装。虽然重启之后能进入到 Windows 安装程序中，也能正常地下一步下一步，但是只要到再努力一小下就会成功的时刻，安装程序就会蹦出 “Windows 无法更新计算机的启动配置，安装无法继续”，然后系统开始自动回滚，结果失败。</li><li>上面的问题我自己也遇到过，不过也解决了，这里就不赘述了，这里只说一下手工安装的步骤。</li></ul><h2 id="手工安装-Windows-操作步骤"><a href="#手工安装-Windows-操作步骤" class="headerlink" title="手工安装 Windows 操作步骤"></a>手工安装 Windows 操作步骤</h2><ol><li>做好以下准备：<ul><li>U 盘：注意文件系统要 FAT32 或者 ExFat 的，FAT32 有4G的限制，ExFat 没限制所以我的U盘是 ExFat 格式的，不知道不同版本有没有限制，如果你用 ExFat 不行的话就试下 FAT32 吧。</li><li>有线键盘、有线鼠标（至少要预备个有线鼠标，因为 Windows 安装程序下没法连接无线的设备）</li><li>下载 Windows 10 64 位安装盘（可以去 <a href="http://msdn.itellyou.cn/">msdn.itellyou.cn</a>下载），将安装盘映像当作压缩包解压到 U 盘上 —— 因为 MacBook 也是 EFI 启动，所以解压就足够了，不需要特意找刻录软件去刻录。</li><li>给 Windows 多划些空间。现代游戏动不动就几十个 G，而 Windows 系统本身再占三四十 G，不划到 100GB 根本不够用。</li></ul></li><li>按住 Command+R 开机，进入 Recovery 模式，完成以下操作：<ul><li><a href="https://support.apple.com/zh-cn/guide/disk-utility/dskutl14027/mac">在磁盘工具给 Windows 分区、格式化</a>。注意两点，第一是记住磁盘容量以免在安装时错误地格式化，第二是尽量把容量计算好，因为调整容量非常麻烦，而且很可能要删分区。</li><li><a href="https://support.apple.com/zh-cn/HT208330">关闭安全启动</a></li></ul></li><li>回到 macOS，启动 BootCamp（新版本叫做 “启动转换助理”），点击菜单栏 “操作” 中的 “下载 Windows 支持软件”，下载完成后相关文件会放到根目录中，把它复制到 U 盘根目录中，这一步不要漏掉，否则后面安装时找不到硬盘。</li><li>插上 U 盘，重启电脑，启动时按住 Option 键，从 U 盘启动。</li><li>进入 Windows 安装程序，把事先预备好的有线键盘和鼠标接上，如果能操作，那么就可以按正常步骤安装 Windows 了，若在选择分区时提示没有硬盘或分区，可以点击 “加载驱动程序” 按钮，找到事先在 macOS 系统里面下载的支持软件，安装 SSD 驱动，使 Windows 安装程序能够发现分区。</li><li>安装成功后，进入 Windows 系统，找到 U 盘里的 BootCamp 支持软件，运行 setup 安装程序，安装成功后重启。</li></ol><p>以这种方式进行安装，除了有点麻烦以及不能在 macOS 的 Boot Camp 界面进行管理（即删除 Windows）以外，其他基本上没什么区别，如果要删除 Windows 的话，就重新进入 macOS 的磁盘工具把 Windows 的分区抹掉就行了。</p><h2 id="调整分区容量"><a href="#调整分区容量" class="headerlink" title="调整分区容量"></a>调整分区容量</h2><p>一旦 Windows 系统用起来了，调整容量将是极其麻烦的事情。如果非扩容不可，建议先备份数据，然后删掉 Windows 分区，全部重来。</p><p>但是，如果 Mac 分区剩余空间比 Windows 系统盘大，那么还可以以一种麻烦的方式完成扩容：将 Windows 系统盘备份到映像，删除 Windows 盘并重新分区，然后恢复备份，修正分区表。如果操作成功，那么就不需要重装系统和各软件，也不需要再调系统设置了。</p><p>注意，操作有风险！如果不熟悉装机以及 Linux/Unix 操作，请不要继续，以免造成系统损坏或数据丢失！</p><p>建议在操作时使各分区容量不相同，而且进行每一步破坏性操作之前确认目标分区容量，以避免误操作。</p><p>按以下步骤操作：</p><ol><li>准备工作：<ul><li>Windows 安装 U 盘，其中已经预备好 Boot Camp 的 “Windows 支持软件”。</li><li>转接线</li><li>USB 键盘和鼠标（这次要敲命令所以一定要准备好键盘）</li></ul></li><li>按住 Command+R 开机，进入 Recovery 模式。</li><li>进入磁盘工具，确认 Windows 安装盘的位置（例如 /dev/disk0s2）以及 Mac 系统盘的名称（例如 Macintosh HD）。如果还是拿不准的话，可以在终端里用 “diskutil info /dev/disk0s2” 这种命令来确认。</li><li>退出磁盘工具，进入终端。假如 Mac 系统盘叫做 Macintosh HD，Windows 系统盘是 /dev/disk0s2，那么需要输入以下命令进行备份：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &quot;/Volumes/Macintosh HD&quot;</span><br><span class="line">dd if=/dev/disk0s2 of=backup.img bs=1m</span><br></pre></td></tr></table></figure><ol start="5"><li>完成后重新进入磁盘工具，删除 Windows 分区，重新调整分区，不要格式化。Windows 分区格式化工作交给 Windows 来做。</li><li>重启，从 U 盘启动 Windows 安装程序，接上鼠标，在 Windows 安装程序界面上进行格式化。</li><li>回到 Mac 的 Recovery 模式，确认新分区的位置是 disk 几 s 几（例如 disk0s4）。</li><li>重新进入终端，恢复映像：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &quot;/Volumes/Macintosh HD&quot;</span><br><span class="line">dd if=backup.img of=/dev/disk0s4 bs=1m</span><br></pre></td></tr></table></figure><ol start="9"><li>这时候 Windows 应该可以重新进入了。但是，dd 并非那种专业 Windows 分区备份还原软件，所以 Windows 分区的容量和剩余空间还是错的，需要修正。再次用 Windows 安装盘启动，接上键盘和鼠标，这次按 Shift+F10 进入命令提示符，然后输入 diskpart，进入分区工具。</li><li>在 diskpart 里输入以下命令（注意命令中的 “0” 和 “4” 要根据实际情况填写）：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">list disk</span><br><span class="line">sel disk 0</span><br><span class="line">list volume</span><br><span class="line">sel volume 4</span><br><span class="line">extend</span><br></pre></td></tr></table></figure><ol start="11"><li>检查两个系统能否正常启动。如果没问题就可以删掉苹果系统里的 /backup.img 了。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我的 MacBook Pro 2015 使用BootCamp能够正常安装 Win 10，但是我的 Mac Mini 2018 使用BootCamp安装 Win 10 的时候，重启就黑屏，怎么也加载不出 Windows 安装程序，重装 Mac 系统等各种方法都试过了，就是不行，所以无奈只能寻找手工安装 Windows 的方式，这是 &lt;a href=&quot;https://plusnan.me/2018/12/14/install-windows-on-macbook-pro-2018/&quot;&gt;参考文章&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;实际上大多数 ISO 系统是可以借助 Boot Camp 安装的，可以去 &lt;a href=&quot;https://msdn.itellyou.cn/&quot;&gt;MSDN I Tell You&lt;/a&gt; 多试几个版本，总有一个能用的，如果版本比较老，装好之后再去 Windows Update 里头做个升级就行了。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Mac 使用指南" scheme="https://karise.cn/categories/Mac-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="mac" scheme="https://karise.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>mac 关闭/开启更新红点</title>
    <link href="https://karise.cn/2021/01/27/Mac/202101271553/"/>
    <id>https://karise.cn/2021/01/27/Mac/202101271553/</id>
    <published>2021-01-27T07:53:00.000Z</published>
    <updated>2023-02-28T03:19:22.713Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用系统偏好设置时，右上角经常出现一个更新提示，不想更新，也不想看到这个红点，所以使用下面方法关闭/开启更新红点。</p></blockquote><a id="more"></a><p>更新提示的设置在文件 <code>~/Library/Preferences/com.apple.systempreferences.plist</code> 中，下文我们使用 <code>defaults</code> 命令读写修改这个文件 <code>AttentionPrefBundleIDs</code> 键的值。</p><p><img data-src="https://file.karise.cn/blog/20210127154845.png"></p><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ defaults write com.apple.systempreferences AttentionPrefBundleIDs  -dict com.apple.preferences.softwareupdate 0</span><br><span class="line">$ killall -SIGTERM cfprefsd  <span class="comment"># 重启偏好设置进程</span></span><br><span class="line">$ killall Dock <span class="comment"># 重启 Dock</span></span><br></pre></td></tr></table></figure><p>这时 <code>Dock</code> 栏上 偏好设置图标右上角的红圈不会显示了，如果偏好设置面板如果是打开状态，软件更新 <code>icon</code> 上还会继续显示数字，重启偏好设置应用后，软件更新 <code>icon</code> 右上角只会显示圆圈，不显示数字。</p><p><img data-src="https://file.karise.cn/blog/20210127155047.png"></p><h2 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ defaults write com.apple.systempreferences AttentionPrefBundleIDs  -dict com.apple.preferences.softwareupdate 1</span><br><span class="line">$ killall -SIGTERM cfprefsd</span><br><span class="line">$ killall Dock</span><br></pre></td></tr></table></figure><p>以上操作不会马上显示更新的红点，或者在面板中显示了红色圆圈，但没有数字，可能是没有触发对新版本的检测，这时我们点击 软件更新 进入这个面板，等待加载新版本信息，再退出来，稍等一会儿儿，更新数字就会出现。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;使用系统偏好设置时，右上角经常出现一个更新提示，不想更新，也不想看到这个红点，所以使用下面方法关闭/开启更新红点。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Mac 使用指南" scheme="https://karise.cn/categories/Mac-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="mac" scheme="https://karise.cn/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>为 Hexo 的 Next 主题添加 Gitalk 评论</title>
    <link href="https://karise.cn/2019/05/31/Hexo/201905311540/"/>
    <id>https://karise.cn/2019/05/31/Hexo/201905311540/</id>
    <published>2019-05-31T07:40:00.000Z</published>
    <updated>2023-02-28T03:13:33.777Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/gitalk/gitalk">Gitalk</a> 是一个基于 <code>Github Issue</code> 的评论插件，使用 <code>Github</code> 帐号登录，界面干净整洁，最喜欢的一点是支持 <code>MarkDown</code> 语法，在个人博客里添加了之后就可以很简便的进行评论和回复了。</p></blockquote><a id="more"></a><hr><p><strong>主要特性：</strong></p><ul><li>使用 <code>Github</code> 登录</li><li>支持多语言 <code>[en, zh-CN, zh-TW, es-ES, fr]</code></li><li>支持个人或组织</li><li>无干扰模式（设置 <code>distractionFreeMode</code> 为 <code>true</code> 开启）</li><li>快捷键提交评论 （<code>cmd</code> | <code>ctrl + enter</code>）</li><li>支持 <code>MarkDown</code> 语法</li></ul><p><strong>界面效果：</strong></p><p><img data-src="https://file.karise.cn/blog/20190531155245.png"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我这边使用的 <a href="https://github.com/iissnan/hexo-theme-next">Next</a> 主题，版本是 <code>5.1.3</code>。</p><h3 id="1-创建-Github-仓库"><a href="#1-创建-Github-仓库" class="headerlink" title="1. 创建 Github 仓库"></a>1. 创建 Github 仓库</h3><p>需要在自己的 <code>Github</code> 账号下创建一个仓库来存放评论，创建的仓库只要 <code>public</code> 就行，其余没要求。</p><h3 id="2-创建-Github-Application"><a href="#2-创建-Github-Application" class="headerlink" title="2. 创建 Github Application"></a>2. 创建 Github Application</h3><p>需要创建一个 <code>Github Application</code> 用来授权登录，如果没有 <a href="https://github.com/settings/applications/new">点击这里申请</a>，<code>Authorization callback URL</code> 填写你主页地址，比如我的就是 <code>https://karise.cn</code>，其他都随意填。</p><h3 id="3-为-Next-主题添加-Gitalk-支持"><a href="#3-为-Next-主题添加-Gitalk-支持" class="headerlink" title="3. 为 Next 主题添加 Gitalk 支持"></a>3. 为 Next 主题添加 Gitalk 支持</h3><ul><li><p>首先创建 <code>Gitalk</code> 的 <code>swig</code> 文件，放在 <code>themes/next/layout/_third-party/comments</code> 文件夹下，命名为 <code>gitalk.swig</code> ，内容如下。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;gitalk-container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      clientID: &#x27;</span><span class="template-variable">&#123;&#123; <span class="name">theme.gitalk.clientID</span> &#125;&#125;</span><span class="xml">&#x27;,</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      clientSecret: &#x27;</span><span class="template-variable">&#123;&#123; <span class="name">theme.gitalk.clientSecret</span> &#125;&#125;</span><span class="xml">&#x27;,</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      repo: &#x27;</span><span class="template-variable">&#123;&#123; <span class="name">theme.gitalk.repo</span> &#125;&#125;</span><span class="xml">&#x27;,</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      owner: &#x27;</span><span class="template-variable">&#123;&#123; <span class="name">theme.gitalk.owner</span> &#125;&#125;</span><span class="xml">&#x27;,</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      admin: [&#x27;</span><span class="template-variable">&#123;&#123; <span class="name">theme.gitalk.admin</span> &#125;&#125;</span><span class="xml">&#x27;],</span></span></span><br><span class="line">      id: location.pathname,</span><br><span class="line"><span class="handlebars"><span class="xml">      distractionFreeMode: &#x27;</span><span class="template-variable">&#123;&#123; <span class="name">theme.gitalk.distractionFreeMode</span> &#125;&#125;</span><span class="xml">&#x27;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    gitalk.render(<span class="string">&#x27;gitalk-container&#x27;</span>)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li><li><p>在主题文件 <code>themes/next/layout/_third-party/comments/index.swig</code> 中引入刚刚添加的文件。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% include &#x27;gitalk.swig&#x27; %&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>themes/next/layout/_partials/comments.swig</code> 文件末找到最后的 <code>&#123;% endif %&#125;</code> 语句，替换为如下代码。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;gitalk-container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>themes/next/_config.yml</code> 文件中添加 <code>Gitalk</code> 的配置。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否启用</span></span><br><span class="line">  <span class="attr">owner:</span> <span class="string">xxx</span> <span class="comment"># 用户名</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">xxx</span> <span class="comment"># 存放评论的仓库名</span></span><br><span class="line">  <span class="attr">clientID:</span> <span class="string">xxx</span> <span class="comment"># Github Application 的 clientID</span></span><br><span class="line">  <span class="attr">clientSecret:</span> <span class="string">xxx</span> <span class="comment"># Github Application 的 clientSecret</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="string">xxx</span> <span class="comment"># 用户名</span></span><br><span class="line">  <span class="attr">distractionFreeMode:</span> <span class="literal">false</span> <span class="comment"># 评论时遮照效果的开关</span></span><br></pre></td></tr></table></figure></li><li><p>最后执行 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code> 重新发布博客即可。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gitalk/gitalk&quot;&gt;Gitalk&lt;/a&gt; 是一个基于 &lt;code&gt;Github Issue&lt;/code&gt; 的评论插件，使用 &lt;code&gt;Github&lt;/code&gt; 帐号登录，界面干净整洁，最喜欢的一点是支持 &lt;code&gt;MarkDown&lt;/code&gt; 语法，在个人博客里添加了之后就可以很简便的进行评论和回复了。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Hexo 博客" scheme="https://karise.cn/categories/Hexo-%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo 博客" scheme="https://karise.cn/tags/Hexo-%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="评论" scheme="https://karise.cn/tags/%E8%AF%84%E8%AE%BA/"/>
    
    <category term="Gitalk" scheme="https://karise.cn/tags/Gitalk/"/>
    
  </entry>
  
  <entry>
    <title>一条命令轻松解决 Mac 上「应用程序 “xxx” 不能打开」的问题</title>
    <link href="https://karise.cn/2019/02/18/Mac/201902181519/"/>
    <id>https://karise.cn/2019/02/18/Mac/201902181519/</id>
    <published>2019-02-18T07:19:00.000Z</published>
    <updated>2023-02-28T03:19:15.680Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>除了在 <code>Mac App Store</code> 下载应用之外，有时候我也会直接在一些网站上下载应用，而这就会出现一些稀奇古怪的问题，比如我下载的应用是经过压缩的打包文件，解压缩之后会发现软件打不开，会显示 <code>应用程序 “xxx” 不能打开</code>，下面即可以通过一条命令轻松解决这个问题。</p></blockquote><a id="more"></a><hr><p>显示的弹窗信息如下：</p><p><img data-src="https://file.karise.cn/blog/20190509172457.jpg"></p><p>其实这个错误主要是解压缩软件在解压文件时，破坏了应用里面可执行文件的权限造成的，当然修复起来也不复杂。</p><ul><li><p>首先在应用上点击右键，选择「显示包内容」：</p><p><img data-src="https://file.karise.cn/blog/20190509172507.jpg"></p></li><li><p>之后依次展开<code>Contents</code> - <code>MacOS</code>，找到对应文件夹下的文件，比如说截图中显示的 <code>StarCraft-II-Setup</code>。如果权限正确的话，该文件应该是一个 <code>Unix</code> 可执行的文件，而不是现在这种类型不明的文件。</p><p><img data-src="https://file.karise.cn/blog/20190509172518.jpg"></p></li><li><p>接下来打开终端，直接输入以下代码（注意 <code>+x</code> 前后都有空格）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x</span><br></pre></td></tr></table></figure></li><li><p>之后再将文件 <code>StarCraft-II-Setup</code> 拖入终端（为了输入完整的执行路径），完整的命令如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x &#x2F;Users&#x2F;liuxiaofeng&#x2F;Downloads&#x2F;StarCraft-II-Setup-CN.app&#x2F;Contents&#x2F;MacOS&#x2F;StarCraft-II-Setup</span><br></pre></td></tr></table></figure><p><img data-src="https://file.karise.cn/blog/20190509172530.jpg"></p></li><li><p>最后点击回车，这时候在访达中原本不明类型的文件现在变成了 Unix 可执行文件，图标也变成正常的了。</p><p><img data-src="https://file.karise.cn/blog/20190509172545.jpg"></p></li><li><p>重新打开下载的软件，你会发现下载的程序可以正常使用并执行了！</p><p><img data-src="https://file.karise.cn/blog/20190509172611.jpg"></p></li></ul><blockquote><p>本文参考自：<a href="https://sspai.com/post/52828">一条命令轻松解决 Mac 上「应用程序 “xxx” 不能打开」的问题 | 一日一技</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;除了在 &lt;code&gt;Mac App Store&lt;/code&gt; 下载应用之外，有时候我也会直接在一些网站上下载应用，而这就会出现一些稀奇古怪的问题，比如我下载的应用是经过压缩的打包文件，解压缩之后会发现软件打不开，会显示 &lt;code&gt;应用程序 “xxx” 不能打开&lt;/code&gt;，下面即可以通过一条命令轻松解决这个问题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Mac 使用指南" scheme="https://karise.cn/categories/Mac-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="mac" scheme="https://karise.cn/tags/mac/"/>
    
    <category term="应用程序" scheme="https://karise.cn/tags/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【iOS 开发】Cocoapods 中多个本地库相互依赖的方法</title>
    <link href="https://karise.cn/2018/10/10/iOS/201810101456/"/>
    <id>https://karise.cn/2018/10/10/iOS/201810101456/</id>
    <published>2018-10-10T06:56:00.000Z</published>
    <updated>2023-02-28T03:16:56.535Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先说一下这里讲的是本地库，并不是私有库，如果想了解 <code>Cocoapods</code> 公共库或者私有库的支持方法可以看我的另一篇文章：<a href="https://www.jianshu.com/p/4d73369b8cf9">【iOS 开发】创建 podspec 文件，给自己写的框架添加 CocoaPos 支持</a> 。</p><p>最近公司项目需要以组件化的架构来重构项目，就是各个模块需要解耦拆分开来，利用 <code>Cocoapods</code> 的管理，主工程只需要将各个模块 <code>pod install</code> 引入即可，开始想要以私有库的方式集成，但是公司项目涉及到多个客户定制开发，定制分支比较多，如果用私有库方式必定要创建多个 <code>Git</code> 仓库分开管理，这样分支管理以及维护成本都大大提高，所以考虑采用本地库的方式将各个模块集成，好处是各个模块的库不需要打 <code>tag</code> 上传至私有库，可以在主工程直接管理各个模块的代码，下面就记录一下遇到的问题。</p></blockquote><a id="more"></a><hr><p>至于如何给自己的模块代码添加 <code>Cocoapods</code> 支持我这边就不说了，不会的看上面贴出来的另一篇文章即可。</p><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p>我的项目工程一共分为以下几个组件：</p><ul><li>测试主工程 (<code>TestProject</code>)</li><li>测试组件1 (<code>TestModule1</code>)</li><li>测试组件2 (<code>TestModule2</code>)</li></ul><p>然后 <code>测试主工程</code> 需要依赖 <code>测试组件1</code> ，而 <code>测试组件1</code> 又需要依赖 <code>测试组件2</code> ，两个组件都是以本地库方式依赖，所以这里就涉及到 <code>Cocoapods</code> 本地库依赖本地库，因为是本地库并没有上传，所以在 <code>podspec</code> 中依赖时会出现找不到库的情况，下面就来说一下解决方法。</p><h2 id="相互依赖的方法"><a href="#相互依赖的方法" class="headerlink" title="相互依赖的方法"></a>相互依赖的方法</h2><h3 id="测试组件2"><a href="#测试组件2" class="headerlink" title="测试组件2"></a>测试组件2</h3><p>由于 <code>测试组件2</code> 并不需要任何依赖，所以 <code>podspec</code> 如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Pod</span>:<span class="string">:Spec.new do |s|</span></span><br><span class="line">    <span class="meta">s.name</span>                      = <span class="string">&#x27;TestModule2&#x27;</span></span><br><span class="line">    <span class="meta">s.version</span>                   = <span class="string">&#x27;1.0.0&#x27;</span></span><br><span class="line">    <span class="meta">s.summary</span>                   = <span class="string">&#x27;测试组件2&#x27;</span></span><br><span class="line">    <span class="meta">s.homepage</span>                  = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">    <span class="meta">s.license</span>                   = <span class="string">&#123; :type =&gt; &#x27;MIT&#x27;, :file =&gt; &#x27;LICENSE&#x27; &#125;</span></span><br><span class="line">    <span class="meta">s.author</span>                    = <span class="string">&#123; &#x27;Karise&#x27; =&gt; &#x27;xxx&#x27; &#125;</span></span><br><span class="line">    <span class="meta">s.source</span>                    = <span class="string">&#123; :git =&gt; &#x27;&#x27;, :tag =&gt; s.version &#125;</span></span><br><span class="line">    <span class="meta">s.platform</span>                  = <span class="string">:ios</span></span><br><span class="line">    <span class="meta">s.ios.deployment_target</span>     = <span class="string">&#x27;9.0&#x27;</span></span><br><span class="line">    <span class="meta">s.swift_version</span>         = <span class="string">&#x27;4.2&#x27;</span></span><br><span class="line">    <span class="meta">s.source_files</span>              = <span class="string">&#x27;TestModule2/*.swift&#x27;</span></span><br><span class="line"><span class="attr">end</span></span><br></pre></td></tr></table></figure><h3 id="测试组件1"><a href="#测试组件1" class="headerlink" title="测试组件1"></a>测试组件1</h3><p>由于 <code>测试组件1</code> 需要依赖 <code>测试组件2</code> ，所以需要添加 <code>s.dependency</code> 依赖， <code>podspec</code> 如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Pod</span>:<span class="string">:Spec.new do |s|</span></span><br><span class="line">    <span class="meta">s.name</span>                      = <span class="string">&#x27;TestModule1&#x27;</span></span><br><span class="line">    <span class="meta">s.version</span>                   = <span class="string">&#x27;1.0.0&#x27;</span></span><br><span class="line">    <span class="meta">s.summary</span>                   = <span class="string">&#x27;测试组件1&#x27;</span></span><br><span class="line">    <span class="meta">s.homepage</span>                  = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">    <span class="meta">s.license</span>                   = <span class="string">&#123; :type =&gt; &#x27;MIT&#x27;, :file =&gt; &#x27;LICENSE&#x27; &#125;</span></span><br><span class="line">    <span class="meta">s.author</span>                    = <span class="string">&#123; &#x27;Karise&#x27; =&gt; &#x27;xxx&#x27; &#125;</span></span><br><span class="line">    <span class="meta">s.source</span>                    = <span class="string">&#123; :git =&gt; &#x27;&#x27;, :tag =&gt; s.version &#125;</span></span><br><span class="line">    <span class="meta">s.platform</span>                  = <span class="string">:ios</span></span><br><span class="line">    <span class="meta">s.ios.deployment_target</span>     = <span class="string">&#x27;9.0&#x27;</span></span><br><span class="line">    <span class="meta">s.swift_version</span>         = <span class="string">&#x27;4.2&#x27;</span></span><br><span class="line">    <span class="meta">s.source_files</span>              = <span class="string">&#x27;TestModule1/*.swift&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">s.dependency</span> <span class="string">&#x27;TestModule2&#x27;  # 这里需要依赖测试组件2</span></span><br><span class="line"><span class="attr">end</span></span><br></pre></td></tr></table></figure><h3 id="测试主工程"><a href="#测试主工程" class="headerlink" title="测试主工程"></a>测试主工程</h3><p>当测试主工程在 <code>podfile</code> 集成 <code>测试组件1</code> 和 <code>测试组件2</code> 时，一般来说，因为 <code>TestModule1</code> 已经在 <code>podspec</code> 中 <code>s.dependency</code> 依赖了 <code>TestModule2</code> ，所以直接 <code>pod &#39;TestModule1&#39;</code> 应该就会自动把 <code>TestModule2</code> 也 <code>pod</code> 下来，但是因为两个组件都是本地库，所以 <code>cocoapods</code> 会找不到 <code>TestModule2</code> 这个本地库，这时候只要在 <code>podfile</code> 中将 <code>TestModule2</code> 也指明本地地址即可，<code>podfile</code> 如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">platform</span> :<span class="string">ios, &#x27;9.0&#x27;</span></span><br><span class="line"><span class="attr">target</span> <span class="string">&#x27;TestProject&#x27; do</span></span><br><span class="line">  <span class="attr">use_frameworks!</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">pod</span> <span class="string">&#x27;TestModule1&#x27;,   :path =&gt;&#x27;../TestModule1/&#x27;</span></span><br><span class="line">  <span class="attr">pod</span> <span class="string">&#x27;TestModule2&#x27;,   :path =&gt;&#x27;../TestModule2/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">end</span></span><br></pre></td></tr></table></figure><p>这里将 <code>TestModule2</code> 的地址也指明，<code>pod &#39;TestModule1&#39;</code> 时就不会出现找不到依赖的情况。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;先说一下这里讲的是本地库，并不是私有库，如果想了解 &lt;code&gt;Cocoapods&lt;/code&gt; 公共库或者私有库的支持方法可以看我的另一篇文章：&lt;a href=&quot;https://www.jianshu.com/p/4d73369b8cf9&quot;&gt;【iOS 开发】创建 podspec 文件，给自己写的框架添加 CocoaPos 支持&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;最近公司项目需要以组件化的架构来重构项目，就是各个模块需要解耦拆分开来，利用 &lt;code&gt;Cocoapods&lt;/code&gt; 的管理，主工程只需要将各个模块 &lt;code&gt;pod install&lt;/code&gt; 引入即可，开始想要以私有库的方式集成，但是公司项目涉及到多个客户定制开发，定制分支比较多，如果用私有库方式必定要创建多个 &lt;code&gt;Git&lt;/code&gt; 仓库分开管理，这样分支管理以及维护成本都大大提高，所以考虑采用本地库的方式将各个模块集成，好处是各个模块的库不需要打 &lt;code&gt;tag&lt;/code&gt; 上传至私有库，可以在主工程直接管理各个模块的代码，下面就记录一下遇到的问题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="iOS 开发" scheme="https://karise.cn/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="https://karise.cn/tags/iOS/"/>
    
    <category term="Cocoapods" scheme="https://karise.cn/tags/Cocoapods/"/>
    
  </entry>
  
  <entry>
    <title>【iOS 开发】利用 Carthage 将项目打包 Framework 并依赖 CocoaPods 第三方库的方法</title>
    <link href="https://karise.cn/2018/09/29/iOS/201809291052/"/>
    <id>https://karise.cn/2018/09/29/iOS/201809291052/</id>
    <published>2018-09-29T02:52:00.000Z</published>
    <updated>2023-02-28T03:16:50.115Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近需要将自己公司的项目的打包成 <code>Framework</code> 然后以 <code>SDK</code> 的形式来供客户使用，但是项目中用到不少 <code>Cocoapods</code> 第三方的库，怎么才能将项目打包 <code>Framework</code> 并依赖 <code>CocoaPods</code> 第三方库呢，网上找了很久都没有找到一篇专门说这个的，让我走了很多的坑，手动打包 <code>Framework</code> 太麻烦，开始尝试了 <a href="https://github.com/CocoaPods/cocoapods-packager">cocoapods-packager</a> 方式打包，但是这个插件貌似对于 <code>Swift</code> 项目的支持并不是很好，尝试很久都没有打包成功，作者貌似也不是很活跃，无奈放弃，最后选择用 <code>Carthage</code> 方式来打包 <code>Framework</code> ，下面就分享一下利用 <code>Carthage</code> 将项目打包 <code>Framework</code> 并依赖 <code>CocoaPods</code> 第三方库的方法。</p></blockquote><a id="more"></a><hr><h2 id="创建工程并打包-Framework"><a href="#创建工程并打包-Framework" class="headerlink" title="创建工程并打包 Framework"></a>创建工程并打包 Framework</h2><p>我这边演示的是 <code>Swift</code> 工程，<code>Objective-C</code> 也是一样的，<a href="https://github.com/karise-guo/FrameworkDemo">演示Demo</a> 我会保留，不懂的可以看一下。</p><h3 id="1-创建-Framework-工程"><a href="#1-创建-Framework-工程" class="headerlink" title="1. 创建 Framework 工程"></a>1. 创建 Framework 工程</h3><ul><li><p>新建一个工程或者在现有工程下创建一个新的 <code>target</code> ，类型需要选择 <code>Coaoa Touch Framework</code> ，这里说一下我的 <code>Xcode</code> 版本是 <code>10.0.0</code> 。</p><p><img data-src="https://file.karise.cn/blog/20190509172139.jpg"></p></li><li><p>由于 <code>Carthage</code> 在 <code>build</code> 时，会自动将设置为 <code>Shared</code> 的 <code>framework target</code> 构建成 <code>framework</code> ，所以需要单击顶部 <code>target</code> ，在弹出选项中选中 <code>Manager Schemes</code>  ，将 <code>framework target</code> 的 <code>Shared</code> 选项选中。</p></li></ul><h3 id="2-创建-podfile-集成第三方库"><a href="#2-创建-podfile-集成第三方库" class="headerlink" title="2. 创建 podfile 集成第三方库"></a>2. 创建 podfile 集成第三方库</h3><ul><li><p>假设我的代码中要用到 <code>Alamofire</code> 这个第三方库（用于演示），然后使用 <code>CocoaPods</code> 在工程中集成 <code>Alamofire</code> ，集成方法和普通项目一模一样。</p></li><li><p>创建 <code>podfile</code> 并加入 <code>pod &#39;Alamofire&#39;</code> ，然后执行 <code>pod install</code> ，然后选择工程下的 <code>FrameworkDemo.xcworkspace</code> 重新打开工程。</p><p><img data-src="https://file.karise.cn/blog/20190509172153.jpg"></p></li></ul><h3 id="3-创建测试代码"><a href="#3-创建测试代码" class="headerlink" title="3. 创建测试代码"></a>3. 创建测试代码</h3><ul><li><p>我这边创建了一个 <code>TestAlamofire.swift</code> 的测试文件，并在里面使用了 <code>Alamofire</code> 这个库，一会打包就打包这个文件。</p></li><li><p>然后编译一下，编译通过，测试代码如下。</p><p><img data-src="https://file.karise.cn/blog/20190509172206.jpg"></p></li></ul><h3 id="4-构建-framework"><a href="#4-构建-framework" class="headerlink" title="4. 构建 framework"></a>4. 构建 framework</h3><ul><li><p>打开终端 <code>cd</code> 到工程目录下，执行以下命令开始打包 <code>framework</code> ，执行完成后会自动将 <code>framework</code> 文件保存在工程的 <code>Carthage/Build/iOS</code> 文件夹下。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">carthage build --no-skip-current</span><br></pre></td></tr></table></figure><p><img data-src="https://file.karise.cn/blog/20190509172218.jpg"></p></li><li><p>到此 <code>framework</code> 就打包完成了，想了解更多关于 <code>Carthage</code> 打包的详情，可以看我另一篇文章：<a href="https://www.jianshu.com/p/8ccb26206730">【iOS 开发】给自己项目添加 Carthage 支持的方法</a> ，方法基本一致，我这边就不详述了。</p></li></ul><h2 id="将-Framework-传到-Cocoapods-仓库"><a href="#将-Framework-传到-Cocoapods-仓库" class="headerlink" title="将 Framework 传到 Cocoapods 仓库"></a>将 Framework 传到 Cocoapods 仓库</h2><p>由于打包好的 <code>framework</code> 需要依赖 <code>Alamofire</code> 这个库，单独运行会报错，如果直接将 <code>framework</code> 给客户让客户自己依赖 <code>Alamofire</code> 的话，并不友好，所以打算将 <code>framework</code> 传到 <code>Cocoapods</code> 仓库，并指定 <code>Alamofire</code> 依赖库，这样客户直接 <code>pod</code> 我们封装好的库即可。</p><h3 id="1-创建-Git-仓库"><a href="#1-创建-Git-仓库" class="headerlink" title="1. 创建 Git 仓库"></a>1. 创建 Git 仓库</h3><ul><li>先创建一个 <code>Git</code> 仓库，仓库中必须包含一个 <code>License</code> 文件，类型为 <code>MIT License</code> 。</li><li>接着 <code>Clone</code> 到本地，将刚才打包的 <code>Framework</code> 放进去，我这边就直接将测试工程放进去了。</li></ul><h3 id="2-创建-podspec-文件"><a href="#2-创建-podspec-文件" class="headerlink" title="2. 创建 podspec 文件"></a>2. 创建 podspec 文件</h3><ul><li><p>在仓库目录下新建一个 <code>podspec</code> 文件，文件名就是 <code>pod</code> 库的名称，我这边叫 <code>FrameworkDemo_Gzz.podspec</code> ，或者使用以下命令创建。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pod spec create FrameworkDemo_Gzz</span><br></pre></td></tr></table></figure><p><img data-src="https://file.karise.cn/blog/20190509172230.jpg"></p></li><li><p>然后打开 <code>podspec</code> 文件，内容编辑如下，内容的具体意思我这边就不详述了。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Pod</span>:<span class="string">:Spec.new do |s|</span></span><br><span class="line">  <span class="meta">s.name</span>                      = <span class="string">&#x27;FrameworkDemo_Gzz&#x27;</span></span><br><span class="line">  <span class="meta">s.version</span>                   = <span class="string">&#x27;1.0.0&#x27;</span></span><br><span class="line">  <span class="meta">s.summary</span>                   = <span class="string">&#x27;测试 Framework&#x27;</span></span><br><span class="line">  <span class="meta">s.homepage</span>                  = <span class="string">&#x27;https://github.com/karise-guo/FrameworkDemo&#x27;</span></span><br><span class="line">  <span class="meta">s.license</span>                   = <span class="string">&#123; :type =&gt; &#x27;MIT&#x27;, :file =&gt; &#x27;LICENSE&#x27; &#125;</span></span><br><span class="line">  <span class="meta">s.author</span>                    = <span class="string">&#123; &#x27;Karise&#x27; =&gt; &#x27;292710547@qq.com&#x27; &#125;</span></span><br><span class="line">  <span class="meta">s.source</span>                    = <span class="string">&#123; :git =&gt; &#x27;https://github.com/karise-guo/FrameworkDemo.git&#x27;, :tag =&gt; s.version &#125;</span></span><br><span class="line">  <span class="meta">s.platform</span>                  = <span class="string">:ios</span></span><br><span class="line">  <span class="meta">s.ios.deployment_target</span>     = <span class="string">&#x27;9.0&#x27;</span></span><br><span class="line">  <span class="meta">s.swift_version</span>             = <span class="string">&#x27;4.0&#x27;</span></span><br><span class="line">  <span class="meta">s.ios.vendored_frameworks</span>   = <span class="string">&#x27;Carthage/Build/iOS/*.framework&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">  # 依赖库</span></span><br><span class="line">  <span class="meta">s.dependency</span> <span class="string">&#x27;Alamofire&#x27;</span></span><br><span class="line"><span class="attr">end</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-验证-podspec-文件"><a href="#3-验证-podspec-文件" class="headerlink" title="3. 验证 podspec 文件"></a>3. 验证 podspec 文件</h3><ul><li><p>编辑完成后，打开终端 <code>cd</code> 到 <code>podspec</code> 所在文件目录下，输入以下命令来验证编译是否通过。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pod lib lint --allow-warnings --verbose</span><br></pre></td></tr></table></figure></li><li><p>验证通过会显示 <code>FrameworkDemo_Gzz passed validation</code> 。</p></li></ul><h3 id="4-给项目打上-tag-并上传"><a href="#4-给项目打上-tag-并上传" class="headerlink" title="4. 给项目打上 tag 并上传"></a>4. 给项目打上 tag 并上传</h3><ul><li><p><code>podspec</code> 文件验证成功后，先将改动后的文件 <code>commit</code> 提交，接着 <code>push</code> 推送到远程仓库 。</p></li><li><p>因为 <code>CocoaPods</code> 是依赖项目的 <code>tag</code> 版本的，所以必须打上 <code>tag</code> 版本，执行以下命令打上 <code>tag</code> 版本，版本名必须要和之前<code>podspec</code> 文件中的 <code>s.version</code> 一致。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag <span class="string">&quot;1.0.0&quot;</span> // 为 git 提交打上 tag</span><br><span class="line">git push --tags // 将 tag 推送到远程仓库</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-发布到-CocoaPods"><a href="#5-发布到-CocoaPods" class="headerlink" title="5. 发布到 CocoaPods"></a>5. 发布到 CocoaPods</h3><ul><li><p>打开终端 <code>cd</code> 到 <code>podspec</code> 所在文件目录下，输入以下命令来发布到 <code>CocoaPods</code> 。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pod trunk push *.podspec --allow-warnings</span><br></pre></td></tr></table></figure></li><li><p>发布成功会显示 <code>successfully published</code> 。</p></li><li><p>到此就发布完成了，我这边讲的比较简单，如果发布 <code>CocoaPods</code> 遇到什么问题或者报错，可以看我的另一篇文章：<a href="https://www.jianshu.com/p/4d73369b8cf9">【iOS 开发】创建 podspec 文件，给自己写的框架添加 CocoaPos 支持</a> ，我这边就不详述了。</p></li></ul><h2 id="测试-Framework-的-Pod-库"><a href="#测试-Framework-的-Pod-库" class="headerlink" title="测试 Framework 的 Pod 库"></a>测试 Framework 的 Pod 库</h2><ul><li><p>新建一个测试工程 <code>Test</code> ，然后将刚才传到 <code>CocoaPods</code> 的库引入，然后执行 <code>pod install</code> 。</p><p><img data-src="https://file.karise.cn/blog/20190509172241.jpg"></p></li><li><p>可以看到 <code>pod</code> 将我们的 <code>framework</code> 和 <code>Alamofire</code> 依赖库一起 <code>pod</code> 下来了。</p><p><img data-src="https://file.karise.cn/blog/20190509172255.jpg"></p></li><li><p>然后在控制器中 <code>import FrameworkDemo</code> 引入我们的库，执行库中用到 <code>Alamofire</code> 的一个方法。</p><p><img data-src="https://file.karise.cn/blog/20190509172325.jpg"></p></li><li><p>编译运行成功，打印结果正常。</p><p><img data-src="https://file.karise.cn/blog/20190509172340.jpg"></p></li></ul><blockquote><p><a href="https://github.com/karise-guo/FrameworkDemo">演示Demo</a> 在这，有不懂的地方可以看一下，希望能够帮助大家少走一些坑。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近需要将自己公司的项目的打包成 &lt;code&gt;Framework&lt;/code&gt; 然后以 &lt;code&gt;SDK&lt;/code&gt; 的形式来供客户使用，但是项目中用到不少 &lt;code&gt;Cocoapods&lt;/code&gt; 第三方的库，怎么才能将项目打包 &lt;code&gt;Framework&lt;/code&gt; 并依赖 &lt;code&gt;CocoaPods&lt;/code&gt; 第三方库呢，网上找了很久都没有找到一篇专门说这个的，让我走了很多的坑，手动打包 &lt;code&gt;Framework&lt;/code&gt; 太麻烦，开始尝试了 &lt;a href=&quot;https://github.com/CocoaPods/cocoapods-packager&quot;&gt;cocoapods-packager&lt;/a&gt; 方式打包，但是这个插件貌似对于 &lt;code&gt;Swift&lt;/code&gt; 项目的支持并不是很好，尝试很久都没有打包成功，作者貌似也不是很活跃，无奈放弃，最后选择用 &lt;code&gt;Carthage&lt;/code&gt; 方式来打包 &lt;code&gt;Framework&lt;/code&gt; ，下面就分享一下利用 &lt;code&gt;Carthage&lt;/code&gt; 将项目打包 &lt;code&gt;Framework&lt;/code&gt; 并依赖 &lt;code&gt;CocoaPods&lt;/code&gt; 第三方库的方法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="iOS 开发" scheme="https://karise.cn/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="https://karise.cn/tags/iOS/"/>
    
    <category term="CocoaPods" scheme="https://karise.cn/tags/CocoaPods/"/>
    
    <category term="Framework" scheme="https://karise.cn/tags/Framework/"/>
    
    <category term="Carthage" scheme="https://karise.cn/tags/Carthage/"/>
    
  </entry>
  
  <entry>
    <title>【iOS 开发】给自己项目添加 Carthage 支持的方法</title>
    <link href="https://karise.cn/2018/09/28/iOS/201809281733/"/>
    <id>https://karise.cn/2018/09/28/iOS/201809281733/</id>
    <published>2018-09-28T09:33:00.000Z</published>
    <updated>2023-02-28T03:16:42.100Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Carthage</code> 是一款 <code>iOS</code> 项目依赖管理工具，与 <code>Cocoapods</code> 有着相似的功能，可以帮助你方便的管理第三方依赖，它会把三方依赖编译成 <code>framework</code> ，以 <code>framework</code> 的形式将三方依赖加入到项目中进行使用和管理，下面记录一下项目添加 <code>Carthage</code> 支持的方法以及 <code>Carthage</code> 的使用方法，方便日后查看。</p></blockquote><a id="more"></a><hr><h2 id="项目添加-Carthage-支持"><a href="#项目添加-Carthage-支持" class="headerlink" title="项目添加 Carthage 支持"></a>项目添加 Carthage 支持</h2><h3 id="1-安装-Carthage"><a href="#1-安装-Carthage" class="headerlink" title="1. 安装 Carthage"></a>1. 安装 Carthage</h3><p>可以到 <a href="https://github.com/Carthage/Carthage/releases">Carthage 项目</a> 下直接下载 <code>Carthage.pkg</code> 文件安装，或者使用 <code>Homebrew</code> 方式安装，终端输入以下命令进行安装。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install carthage</span><br></pre></td></tr></table></figure><h3 id="2-创建一个支持-Carthage-的工程"><a href="#2-创建一个支持-Carthage-的工程" class="headerlink" title="2. 创建一个支持 Carthage 的工程"></a>2. 创建一个支持 Carthage 的工程</h3><ul><li><code>Carthage</code> 仅支持 <code>dynamic frameworks</code> 也就是动态库，可以新建一个工程或者在现有工程下创建一个新的 <code>target</code> ，类型需要选择 <code>Coaoa Touch Framework</code> 。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509171953.jpg"></p><ul><li>打开项目配置，选择 <code>framework target</code> 的 <code>Build Phases</code> ，将需要暴露的 <code>.h</code> 文件拖拽到 <code>Public</code> 里面，将相应的 <code>.m</code> 文件拖拽到 <code>Compile source</code> 里面。</li><li>如果你的 <code>framework target</code> 名称与你想要打包构建的 <code>framework</code> 名称不一致，选中 <code>Build Settings</code> 选项卡，搜索 <code>Packaging</code> ，把 <code>Produce Module Name</code> 和 <code>Produce Name</code> 改成你想要构建的 <code>framework</code> 名称。</li><li>如果你使用了类别，那么你需要在 <code>Build Settings</code> 的 <code>Linking</code> 的 <code>Other Linker Flags</code> 里加上 <code>-all_load</code> 。</li><li>如果你想你的工程支持 <code>bitcode</code> ，需要在 <code>Other C Flags</code> 里加上 <code>-fembed-bitcode</code> 。</li><li>由于 <code>Carthage</code> 在 <code>build</code> 时，会自动将设置为 <code>Shared</code> 的 <code>framework target</code> 构建成 <code>framework</code> ，所以需要单击顶部 <code>target</code> ，在弹出选项中选中 <code>Manager Schemes</code>  ，将 <code>framework target</code> 的 <code>Shared</code> 选项选中。</li></ul><h3 id="3-构建-framework"><a href="#3-构建-framework" class="headerlink" title="3. 构建 framework"></a>3. 构建 framework</h3><ul><li><p>打开终端 <code>cd</code> 到工程目录下，执行以下命令开始打包 <code>framework</code> ，执行完成后会自动将 <code>framework</code> 文件保存在工程的 <code>Carthage/Build</code> 文件夹下。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">carthage build --no-skip-current</span><br></pre></td></tr></table></figure></li><li><p>然后将生成的 <code>framework</code> 文件拖进测试项目进行测试即可，具体就不说了。</p></li></ul><h3 id="4-发布并打上-tag"><a href="#4-发布并打上-tag" class="headerlink" title="4. 发布并打上 tag"></a>4. 发布并打上 tag</h3><ul><li><p>测试没问题后，将工程 <code>push</code> 并打上 <code>tag</code> 即可，<code>tag</code> 名称必须是版本号。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag 1.0.0</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure></li><li><p>这样你的项目就已经支持 <code>Carthage</code> 了，其他开发者就可以使用 <code>Carthage</code> 来管理你的项目依赖了，只需要将 <code>framework</code> 工程 <code>push</code> 上去即可，打包生成的测试 <code>framework</code> 文件不需要 <code>push</code>。</p></li></ul><h2 id="使用-Cathage-依赖第三方库"><a href="#使用-Cathage-依赖第三方库" class="headerlink" title="使用 Cathage 依赖第三方库"></a>使用 Cathage 依赖第三方库</h2><h3 id="1-创建并编辑-Cartfile"><a href="#1-创建并编辑-Cartfile" class="headerlink" title="1. 创建并编辑 Cartfile"></a>1. 创建并编辑 Cartfile</h3><ul><li><p>在工程目录下创建一个名为 <a href="https://link.jianshu.com/?t=https://github.com/Carthage/Carthage/blob/master/Documentation/Artifacts.md#cartfile">Cartfile</a> 的文件，可以使用以下命令创建。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">touch Cartfile</span><br></pre></td></tr></table></figure></li><li><p>然后在  <a href="https://link.jianshu.com/?t=https://github.com/Carthage/Carthage/blob/master/Documentation/Artifacts.md#cartfile">Cartfile</a> 文件中指明想要依赖的第三方库。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">github</span> <span class="string">&quot;ReactiveCocoa/ReactiveCocoa&quot; // 不指定版本</span></span><br><span class="line"><span class="attr">github</span> <span class="string">&quot;ReactiveCocoa/ReactiveCocoa&quot; &gt;= 1.0.0 // 大于等于 1.0.0 版本</span></span><br><span class="line"><span class="attr">github</span> <span class="string">&quot;ReactiveCocoa/ReactiveCocoa&quot; ~&gt; 1.0.0 // 1.0.0 及以上的兼容版本 &lt; 2.0.0</span></span><br><span class="line"><span class="attr">github</span> <span class="string">&quot;ReactiveCocoa/ReactiveCocoa&quot; == 1.0.0 // 指定为 1.0.0 版本</span></span><br><span class="line"><span class="attr">github</span> <span class="string">&quot;ReactiveCocoa/ReactiveCocoa&quot; &quot;branch&quot; // 指定特定的分支、tag</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-更新并构建-framework"><a href="#2-更新并构建-framework" class="headerlink" title="2. 更新并构建 framework"></a>2. 更新并构建 framework</h3><ul><li><p>编辑完成后，在终端中 <code>cd</code> 到  <a href="https://link.jianshu.com/?t=https://github.com/Carthage/Carthage/blob/master/Documentation/Artifacts.md#cartfile">Cartfile</a> 所在目录下，执行以下命令构建第三方库的 <code>framework</code> 。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">carthage update --platform iOS</span><br></pre></td></tr></table></figure></li><li><p>执行完成后会自动将第三方库 <code>clone</code> 到 <a href="https://link.jianshu.com/?t=https://github.com/Carthage/Carthage/blob/master/Documentation/Artifacts.md#carthagecheckouts">Carthage/Checkouts</a> 文件夹下，然后会自动打包成相应的 <code>framework</code> 文件，打包完的文件会保存在 <a href="https://link.jianshu.com/?t=https://github.com/Carthage/Carthage/blob/master/Documentation/Artifacts.md#carthagebuild">Carthage/Build</a> 文件夹下。</p></li></ul><h3 id="3-工程配置"><a href="#3-工程配置" class="headerlink" title="3. 工程配置"></a>3. 工程配置</h3><ul><li><p>打开工程 <code>target</code> 的 <code>General</code> 配置，将 <a href="https://link.jianshu.com/?t=https://github.com/Carthage/Carthage/blob/master/Documentation/Artifacts.md#carthagebuild">Carthage/Build</a> 下生成的 <code>framework</code> 文件拖拽到 <code>Linked Frameworks and Libraries</code> 选项中。</p></li><li><p>打开工程 <code>target</code> 的 <code>Build Phases</code>  配置，点击 <code>+</code> 选择 <code>New Run Script Phase</code> ，创建一个 <code>Script</code> ，添加以下内容：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin/carthage copy-frameworks</span><br></pre></td></tr></table></figure></li><li><p>然后添加相应的内容到下面的 <code>Input Files</code>（举例）：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$(SRCROOT)/Carthage/Build/iOS/ReactiveCocoa.framework</span><br></pre></td></tr></table></figure><p><img data-src="https://file.karise.cn/blog/20190509172008.jpg"></p></li><li><p>这个脚本是为了处理 <a href="https://link.jianshu.com/?t=http://www.openradar.me/radar?id=6409498411401216">App Store 提交的 bug</a>，解决 <code>App</code> 因为使用的 <code>frameworks</code> 包含二进制图像的 <code>iOS</code> 模拟器在提交 <code>App Store</code> 时会被自动拒绝的问题。</p></li></ul><h3 id="4-Cathage-的目录结构"><a href="#4-Cathage-的目录结构" class="headerlink" title="4. Cathage 的目录结构"></a>4. Cathage 的目录结构</h3><p>在使用 <code>Carthage</code>  管理 <code>frameworks</code> 时，工程根目录下与 <code>Cartfile</code> 同级的会存在 <code>Cartfile.resolved</code> 文件和<br> <code>Carthage</code> 文件夹，<code>Carthage</code> 文件夹又包含 <code>Build</code> 和 <code>Checkouts</code>两个文件夹。</p><ul><li><code>Cartfile.resolved</code>文件<br> 包含已经添加的 <code>frameworks</code> 信息，包括依赖名称和当前使用的版本信息。</li><li><code>Checkouts</code> 文件夹<br> 包含所有 <code>frameworks</code> 源码信息，在执行 <code>carthage build</code> 时，会直接使用里面的 <code>project</code> 或者 <code>workspace</code> 相应的 <code>scheme</code> 来构建相应的 <code>framework</code> 。</li><li><code>Build</code> 文件夹<br> 包含所有的二进制构建结果，包括 <code>.framework</code> 二进制文件和 <code>.dSYM</code> 等文件。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Carthage&lt;/code&gt; 是一款 &lt;code&gt;iOS&lt;/code&gt; 项目依赖管理工具，与 &lt;code&gt;Cocoapods&lt;/code&gt; 有着相似的功能，可以帮助你方便的管理第三方依赖，它会把三方依赖编译成 &lt;code&gt;framework&lt;/code&gt; ，以 &lt;code&gt;framework&lt;/code&gt; 的形式将三方依赖加入到项目中进行使用和管理，下面记录一下项目添加 &lt;code&gt;Carthage&lt;/code&gt; 支持的方法以及 &lt;code&gt;Carthage&lt;/code&gt; 的使用方法，方便日后查看。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="iOS 开发" scheme="https://karise.cn/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="https://karise.cn/tags/iOS/"/>
    
    <category term="Carthage" scheme="https://karise.cn/tags/Carthage/"/>
    
  </entry>
  
  <entry>
    <title>mac 上配置 aria2 加快下载速度的方法</title>
    <link href="https://karise.cn/2018/09/18/Mac/201809181727/"/>
    <id>https://karise.cn/2018/09/18/Mac/201809181727/</id>
    <published>2018-09-18T09:27:00.000Z</published>
    <updated>2023-02-28T03:18:38.017Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>mac</code> 用户肯定都受够了各种下载限速，浏览器自带的下载器极为蛋疼，花点时间来配置 <code>aria2</code>，结合 <code>Chrome</code> 插件，一次配置终身受益。</p></blockquote><a id="more"></a><hr><h2 id="aria2-是什么？"><a href="#aria2-是什么？" class="headerlink" title="aria2 是什么？"></a>aria2 是什么？</h2><p><code>aria2</code> 是一款支持多种协议的轻量级命令行下载工具。有以下特性：</p><ul><li><p>多线程连线：<code>aria2</code> 会自动从多个线程下载文件，并充分利用你的带宽。</p></li><li><p>轻量：运行时不会占用过多资源，根据官方介绍，内存占用通常在 <code>4MB~9MB</code> ，使用 <code>BitTorrent</code> 协议，下行速度 <code>2.8MB/s</code> 时 <code>CPU</code> 占用率约 <code>6%</code> 。</p></li><li><p>全功能 <code>BitTorrent</code> 客户端。</p></li><li><p>支持 <code>RPC</code> 界面远程控制。</p></li></ul><h2 id="1-安装-Homebrew"><a href="#1-安装-Homebrew" class="headerlink" title="1. 安装 Homebrew"></a>1. 安装 Homebrew</h2><p>由于是使用 <code>Homebrew</code> 方式安装，所以需要先安装 <code>Homebrew</code> ，已经装过了可以跳过这一步，终端输入以下命令安装。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2-安装-aria2"><a href="#2-安装-aria2" class="headerlink" title="2. 安装 aria2"></a>2. 安装 aria2</h2><p>在终端输入以下命令安装。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install aria2</span><br></pre></td></tr></table></figure><h2 id="3-设置配置文件"><a href="#3-设置配置文件" class="headerlink" title="3. 设置配置文件"></a>3. 设置配置文件</h2><p><code>aria2</code> 提供两种方式使用，一种是直接命令行模式下载，不推荐使用这种方法，推荐使用另外一种 <code>RPC</code> 模式，这种方式 <code>aria2</code> 启动之后只会安静的等待下载请求，下载完成后也只会安静的驻留后台不会自动退出。而使用 <code>RPC</code> 模式推荐做一个配置文件方便使用。</p><p>我们把配置文件放在 <code>~/.aria2</code> 下，终端依次输入以下命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir .aria2</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> .aria2</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">touch aria2.conf</span><br></pre></td></tr></table></figure><p>接着打开 <code>Finder</code>，利用 <code>shift + command + G</code> 进入路径：<code>~/.aria2/aria2.conf</code>，用文本编辑器打开 <code>aria2.conf</code>，将 <a href="https://blog.icehoney.me/about">雪月秋水君</a> 提供的以下配置直接拷贝进去：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用户名</span></span><br><span class="line"><span class="comment">#rpc-user=user</span></span><br><span class="line"><span class="comment">#密码</span></span><br><span class="line"><span class="comment">#rpc-passwd=passwd</span></span><br><span class="line"><span class="comment">#上面的认证方式不建议使用,建议使用下面的token方式</span></span><br><span class="line"><span class="comment">#设置加密的密钥</span></span><br><span class="line"><span class="comment">#rpc-secret=token</span></span><br><span class="line"><span class="comment">#允许rpc</span></span><br><span class="line"><span class="meta">enable-rpc</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#允许所有来源, web界面跨域权限需要</span></span><br><span class="line"><span class="meta">rpc-allow-origin-all</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#允许外部访问，false的话只监听本地端口</span></span><br><span class="line"><span class="meta">rpc-listen-all</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#RPC端口, 仅当默认端口被占用时修改</span></span><br><span class="line"><span class="comment">#rpc-listen-port=6800</span></span><br><span class="line"><span class="comment">#最大同时下载数(任务数), 路由建议值: 3</span></span><br><span class="line"><span class="meta">max-concurrent-downloads</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#断点续传</span></span><br><span class="line"><span class="attr">continue</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#同服务器连接数</span></span><br><span class="line"><span class="meta">max-connection-per-server</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要</span></span><br><span class="line"><span class="meta">min-split-size</span>=<span class="string">10M</span></span><br><span class="line"><span class="comment">#单文件最大线程数, 路由建议值: 5</span></span><br><span class="line"><span class="attr">split</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#下载速度限制</span></span><br><span class="line"><span class="meta">max-overall-download-limit</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#单文件速度限制</span></span><br><span class="line"><span class="meta">max-download-limit</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#上传速度限制</span></span><br><span class="line"><span class="meta">max-overall-upload-limit</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#单文件速度限制</span></span><br><span class="line"><span class="meta">max-upload-limit</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#断开速度过慢的连接</span></span><br><span class="line"><span class="comment">#lowest-speed-limit=0</span></span><br><span class="line"><span class="comment">#验证用，需要1.16.1之后的release版本</span></span><br><span class="line"><span class="comment">#referer=*</span></span><br><span class="line"><span class="comment">#文件保存路径, 默认为当前启动位置</span></span><br><span class="line"><span class="attr">dir</span>=<span class="string">/Users/xxx/Downloads</span></span><br><span class="line"><span class="comment">#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本</span></span><br><span class="line"><span class="comment">#disk-cache=0</span></span><br><span class="line"><span class="comment">#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)</span></span><br><span class="line"><span class="comment">#enable-mmap=true</span></span><br><span class="line"><span class="comment">#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长</span></span><br><span class="line"><span class="comment">#所需时间 none &lt; falloc ? trunc « prealloc, falloc和trunc需要文件系统和内核支持</span></span><br><span class="line"><span class="meta">file-allocation</span>=<span class="string">prealloc</span></span><br></pre></td></tr></table></figure><p>默认下载路径的 <code>/Users/xxx/Downloads</code> 可以改为任何你想要的绝对路径。此处写为 <code>Downloads</code> 目录，<code>xxx</code> 请自行替换成你的 <code>mac</code> 用户名，然后保存，退出编辑器。</p><h2 id="4-启动-RPC-模式"><a href="#4-启动-RPC-模式" class="headerlink" title="4. 启动 RPC 模式"></a>4. 启动 RPC 模式</h2><p>在终端输入以下命令启动 <code>RPC</code> 模式，将 <code>xxx</code> 替换成你的 <code>mac</code> 用户名。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">aria2c --conf-path=<span class="string">&quot;/Users/xxx/.aria2/aria2.conf&quot;</span> -D</span><br></pre></td></tr></table></figure><h2 id="5-开始使用"><a href="#5-开始使用" class="headerlink" title="5. 开始使用"></a>5. 开始使用</h2><p>下载 <code>chrome</code> 浏览器下载插件：<a href="https://github.com/jae-jae/Camtd">Camtd - Aria2下载管理器</a>, 下载完成后右键下载链接点击 <code>Send to Aria2</code> 即可下载，也支持拦截下载。</p><p><img data-src="https://file.karise.cn/blog/20190509172051.jpg"></p><p><img data-src="https://file.karise.cn/blog/20190509172102.jpg"></p><p>这个插件不满意的话，也可以搜索其他类似插件，但必须启动 <code>RPC</code> 模式才能够使用此类插件。</p><blockquote><p>本文部分内容参考自 <a href="https://sspai.com/post/32167">Mac 上使用百度网盘很烦躁？花点时间配置 aria2 吧</a> 。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;mac&lt;/code&gt; 用户肯定都受够了各种下载限速，浏览器自带的下载器极为蛋疼，花点时间来配置 &lt;code&gt;aria2&lt;/code&gt;，结合 &lt;code&gt;Chrome&lt;/code&gt; 插件，一次配置终身受益。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Mac 使用指南" scheme="https://karise.cn/categories/Mac-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="mac" scheme="https://karise.cn/tags/mac/"/>
    
    <category term="aria2" scheme="https://karise.cn/tags/aria2/"/>
    
    <category term="下载" scheme="https://karise.cn/tags/%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>【iOS 开发】一个音频格式转换库 GZZAudioConverter</title>
    <link href="https://karise.cn/2018/05/28/iOS/201805280923/"/>
    <id>https://karise.cn/2018/05/28/iOS/201805280923/</id>
    <published>2018-05-28T01:23:06.000Z</published>
    <updated>2023-02-28T03:16:36.700Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>大多数代码源自于 <a href="https://github.com/lixing123/ExtAudioFileConverter">ExtAudioFileConverter</a>，因为网上关于音频格式转换的太少了，而且还特别麻烦，故封装为 <code>Cocoapods</code> 库，方便使用，转换 <code>MP3</code> 格式需要用到 <code>lame</code> 静态库，使用 <code>pod</code> 之后不需要单独集成 <code>lame</code> 静态库，直接 <code>pod install</code> 即可使用，这是库的地址：<a href="https://github.com/karise-guo/GZZAudioConverter">GZZAudioConverter</a> 。</p></blockquote><a id="more"></a><hr><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p> 仅支持 <code>CocoaPods</code>，将如下代码加入 <code>Podfile</code> 文件中。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">pod</span> <span class="string">&#x27;GZZAudioConverter&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Useage"><a href="#Useage" class="headerlink" title="Useage"></a>Useage</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如：转换为 MP3</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_queue_create(<span class="literal">NULL</span>, DISPATCH_QUEUE_SERIAL), ^ &#123;</span><br><span class="line">    GZZAudioConverter *converter = [[GZZAudioConverter alloc] init];</span><br><span class="line">    converter.inputFile = <span class="string">@&quot;/var/mobile/Containers/Data/Application/xxx/Documents/xxx.wav&quot;</span>;</span><br><span class="line">    converter.outputFile = <span class="string">@&quot;/var/mobile/Containers/Data/Application/xxx/Documents/xxx.mp3&quot;</span>;</span><br><span class="line">    converter.outputFileType = kAudioFileMP3Type;</span><br><span class="line">    converter.outputFormatID = kAudioFormatMPEGLayer3;</span><br><span class="line">    <span class="built_in">BOOL</span> success = [converter convert];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^ &#123;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;转换成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;转换失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>注意：文件格式和数据格式要根据你要转换的音频格式来设置，不同文件格式对应的数据格式是不同的，这是关于文件格式和数据格式的 <a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/CoreAudioOverview/SupportedAudioFormatsMacOSX/SupportedAudioFormatsMacOSX.html">说明文档</a> 。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采样率</span></span><br><span class="line">converter.outputSampleRate = <span class="number">44100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声道数</span></span><br><span class="line">converter.outputNumberChannels = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位深</span></span><br><span class="line">converter.outputBitDepth = BitDepth_16;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件格式</span></span><br><span class="line">converter.outputFileType = kAudioFileWAVEType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据格式</span></span><br><span class="line">converter.outputFormatID = kAudioFormatLinearPCM;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;大多数代码源自于 &lt;a href=&quot;https://github.com/lixing123/ExtAudioFileConverter&quot;&gt;ExtAudioFileConverter&lt;/a&gt;，因为网上关于音频格式转换的太少了，而且还特别麻烦，故封装为 &lt;code&gt;Cocoapods&lt;/code&gt; 库，方便使用，转换 &lt;code&gt;MP3&lt;/code&gt; 格式需要用到 &lt;code&gt;lame&lt;/code&gt; 静态库，使用 &lt;code&gt;pod&lt;/code&gt; 之后不需要单独集成 &lt;code&gt;lame&lt;/code&gt; 静态库，直接 &lt;code&gt;pod install&lt;/code&gt; 即可使用，这是库的地址：&lt;a href=&quot;https://github.com/karise-guo/GZZAudioConverter&quot;&gt;GZZAudioConverter&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="iOS 开发" scheme="https://karise.cn/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="https://karise.cn/tags/iOS/"/>
    
    <category term="格式转换" scheme="https://karise.cn/tags/%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>mac 更改所有文件夹显示选项的方法</title>
    <link href="https://karise.cn/2018/04/12/Mac/201804121027/"/>
    <id>https://karise.cn/2018/04/12/Mac/201804121027/</id>
    <published>2018-04-12T02:27:20.000Z</published>
    <updated>2023-02-28T03:18:25.071Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>mac</code> 的 <code>Finder</code> 中文件夹的显示选项只在当前目录生效，每次新目录都得重新选择显示选项，强迫症表示非常不爽，下面是如何一次性更改所有文件夹显示选项的方法。</p></blockquote><a id="more"></a><hr><ul><li><p>打开 <code>Finder</code>，使劲点击 <code>⌘ + ↑</code> 数次，直到没反应可查看到磁盘的图标为止。</p></li><li><p>进入磁盘，右键空白处打开 <code>查看显示选项</code> ，在显示选项内调整好自己想要的效果后点击下方 <code>用作默认</code> 。</p></li><li><p>打开终端界面输入以下命令，回车后根据提示输入你的账户密码再回车等待即可。</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo find / -name .DS_Store -<span class="built_in">exec</span> rm &#123;&#125; +</span><br></pre></td></tr></table></figure><ul><li>完成后，点击菜单栏左上角的小苹果图标选择 <code>强制退出</code> ，在菜单内选择 <code>Finder</code> 后点击 <code>重新开启</code> 完成。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;mac&lt;/code&gt; 的 &lt;code&gt;Finder&lt;/code&gt; 中文件夹的显示选项只在当前目录生效，每次新目录都得重新选择显示选项，强迫症表示非常不爽，下面是如何一次性更改所有文件夹显示选项的方法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Mac 使用指南" scheme="https://karise.cn/categories/Mac-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="mac" scheme="https://karise.cn/tags/mac/"/>
    
    <category term="文件夹显示选项" scheme="https://karise.cn/tags/%E6%96%87%E4%BB%B6%E5%A4%B9%E6%98%BE%E7%A4%BA%E9%80%89%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>mac 使用 BootCamp 安装双系统时出现磁盘分区错误的解决方法.md</title>
    <link href="https://karise.cn/2018/02/11/Mac/201802111604/"/>
    <id>https://karise.cn/2018/02/11/Mac/201802111604/</id>
    <published>2018-02-11T08:04:09.000Z</published>
    <updated>2023-02-28T03:18:20.603Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在使用 <code>BootCamp</code> 安装 <code>Windows</code> 双系统时，突然出现 <code>您的磁盘未能分区</code> 的错误，以前一直好好的，突然就报错了，我的系统版本是 <code>macOS High Sierra 10.13.3</code> ，经过一番搜索终于解决了，下面记录一下解决方法。</p></blockquote><a id="more"></a><hr><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ul><li>如果开启了磁盘加密，请到 <code>设置</code> - <code>安全性与隐私</code> - <code>文件保险箱</code> 关闭加密（时间较长，耐心等待）</li></ul><p><img data-src="https://file.karise.cn/blog/20190509172022.jpg"></p><ul><li>若没有加密，重启电脑，开机时按住 <code>command + R</code> 进入恢复模式，选择磁盘工具，找到你的 <code>macOS</code> 所在硬盘分区，点击急救，运行完成之后重启，多试几次。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509172033.jpg"></p><ul><li>若上述两种方法都不能解决问题，那就是 <code>Time Machine（时间机器）</code> 的本地快照造成的问题，将 <code>Time Machine</code> 的自动备份关闭，然后打开终端输入以下命令，就能够删除存储在本地磁盘上本地快照，一般本地快照会占用本地磁盘好几十个G的容量，也能够解决磁盘容量被无故占用的问题。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tmutil thinlocalsnapshots / 9999999999999999</span><br></pre></td></tr></table></figure><ul><li>打开终端输入以下命令能够开启和关闭本地快照功能。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 关闭本地快照</span><br><span class="line">sudo tmutil disablelocal</span><br><span class="line"></span><br><span class="line">// 开启本地快照</span><br><span class="line">sudo tmutil enablelocal</span><br></pre></td></tr></table></figure><ul><li>如果上述方法都没有效果的话，那就重装 <code>mac</code> 系统把（节哀）。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近在使用 &lt;code&gt;BootCamp&lt;/code&gt; 安装 &lt;code&gt;Windows&lt;/code&gt; 双系统时，突然出现 &lt;code&gt;您的磁盘未能分区&lt;/code&gt; 的错误，以前一直好好的，突然就报错了，我的系统版本是 &lt;code&gt;macOS High Sierra 10.13.3&lt;/code&gt; ，经过一番搜索终于解决了，下面记录一下解决方法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Mac 使用指南" scheme="https://karise.cn/categories/Mac-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="mac" scheme="https://karise.cn/tags/mac/"/>
    
    <category term="Windows" scheme="https://karise.cn/tags/Windows/"/>
    
    <category term="BootCamp" scheme="https://karise.cn/tags/BootCamp/"/>
    
    <category term="双系统" scheme="https://karise.cn/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="分区错误" scheme="https://karise.cn/tags/%E5%88%86%E5%8C%BA%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>iOS 忘记访问限制的密码后找回的方法</title>
    <link href="https://karise.cn/2018/01/29/Other/201801291605/"/>
    <id>https://karise.cn/2018/01/29/Other/201801291605/</id>
    <published>2018-01-29T08:05:34.000Z</published>
    <updated>2023-02-28T03:20:34.719Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先说明一下不是解锁密码，是 <code>设置 - 通用 - 访问限制</code> 的密码，本人亲测已经成功找回，并且不需要恢复或升级 <code>iPhone</code> 系统、不需要恢复备份、不需要越狱，所以数据不会丢失一个字节，此方法适用于：<code>iOS 11/10/9/8/7/6/5 (iPhone, iPod &amp; iPad)</code> 。</p></blockquote><a id="more"></a><hr><h2 id="苹果官网的方法"><a href="#苹果官网的方法" class="headerlink" title="苹果官网的方法"></a>苹果官网的方法</h2><p>由于 <code>访问限制</code> 的密码只会在设置的时候进行验证，而且没有提示，如果自己不记录或者随意设置密码的话，时间一长，就很容易忘记。</p><p>根据官网的方法需要恢复 <code>iPhone</code> ，并且重置为新 <code>iPhone</code> ，才能清除 <code>访问限制密码</code> ，所以 <code>iPhone</code> 中的所有数据都会丢失，如果通过恢复 <code>iPhone</code> 的 <code>iTunes</code> 备份，<code>访问限制密码</code> 仍然与备份前一样，而且输入密码的错误次数仍然也记录着。</p><p>不过，可以通过无数次的尝试来猜密码，猜得次数达到 <code>6</code> 次左右，就需要等待一个小时才能再猜，这时只能恢复 <code>iTunes</code> 备份才可以将猜错的次数清空，但是密码依旧在。</p><h2 id="密码找回的方法"><a href="#密码找回的方法" class="headerlink" title="密码找回的方法"></a>密码找回的方法</h2><ul><li><p>首先需要将当前的手机系统备份一下，可以用 <a href="https://www.apple.com/cn/itunes/download/">iTunes</a> 或者其他的手机管理工具来备份，备份的时候不要选择 <code>备份加密</code> 选项，下面是不同系统下 <code>iTunes</code> 默认备份的目录。</p></li><li><p><strong>Windows 系统：</strong> 打开计算机，在路径中输入 <code>%appdata%</code>（英文，建议复制），然后回车，然后依次打开文件夹 <code>Apple Computer\MobileSync\Backup\</code> 。</p></li><li><p><strong>macOS 系统：</strong> 打开 <code>Finder</code> ，按下 <code>shift + command + G</code> 打开前往文件夹，然后输入 <code>~/Library/Application Support/MobileSync/Backup/</code> 前往即可。</p></li><li><p>备份完以后到自己系统相应路径下，找到刚才自己的备份目录，然后找到一个名为 <code>39</code> 的文件夹。</p></li></ul><p><img data-src="https://file.karise.cn/blog/20190509172353.jpg"></p><ul><li>然后在 <code>39</code> 文件夹下找到一个名为 <code>398bc9c2aeeab4cb0c12ada0f52eea12cf14f40b</code> 的文件。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509172404.jpg"></p><ul><li><code>Windows</code> 系统可以用记事本打开，<code>Mac</code> 直接双击打开即可，打开后找到如下的两串字符。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509172416.jpg"></p><ul><li>然后打开 <a href="http://ios7hash.derson.us/">密码解析网站</a> ，将较长的一串复制到 <code>RestrictionsPasswordKey</code> 中，较短的一串复制到 <code>RestrictionsPasswordSalt</code> 中，然后点击 <code>Search for Code</code> 。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509172428.jpg"></p><ul><li>然后程序会从 <code>0000</code> 开始逐一递增进行密码匹配，一直到找到密码为止，设置的密码数字越大，匹配的时间越长，匹配成功后会跳出提示。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509172440.jpg"></p><ul><li>此方法是通过 <code>JavaScript</code> 脚本进行计算破解的，所以运行的速度与本地电脑的配置有关，也可以同时打开多个页面，设置不同的 <code>Starting Passcode</code> 和 <code>Last Search Code</code> ，分段进行搜索，从而提高搜索的速度。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;先说明一下不是解锁密码，是 &lt;code&gt;设置 - 通用 - 访问限制&lt;/code&gt; 的密码，本人亲测已经成功找回，并且不需要恢复或升级 &lt;code&gt;iPhone&lt;/code&gt; 系统、不需要恢复备份、不需要越狱，所以数据不会丢失一个字节，此方法适用于：&lt;code&gt;iOS 11/10/9/8/7/6/5 (iPhone, iPod &amp;amp; iPad)&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="其他相关" scheme="https://karise.cn/categories/%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="iOS" scheme="https://karise.cn/tags/iOS/"/>
    
    <category term="iPhone" scheme="https://karise.cn/tags/iPhone/"/>
    
    <category term="访问限制" scheme="https://karise.cn/tags/%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6/"/>
    
    <category term="忘记密码" scheme="https://karise.cn/tags/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Magic Mouse 苹果鼠标移动速度改快的方法</title>
    <link href="https://karise.cn/2018/01/20/Mac/201801201111/"/>
    <id>https://karise.cn/2018/01/20/Mac/201801201111/</id>
    <published>2018-01-20T03:11:01.000Z</published>
    <updated>2023-02-28T03:18:11.226Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>买了一个 <code>Magic Mouse</code> 之后发现移动速度比之前鼠标要慢好多，设置里已经设置到最快了还是很慢，非常不习惯，最后查到可以在终端里输入命令调整 <code>Magic Mouse</code> 的移动速度，下面记录一下方法。</p></blockquote><a id="more"></a><hr><ul><li>打开终端输入以下命令可以查看当前鼠标的速度，一般设置里调到最快的话，就是 <code>3</code> 的速度。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">defaults <span class="built_in">read</span> -g com.apple.mouse.scaling</span><br></pre></td></tr></table></figure><ul><li>然后输入以下命令可以设置鼠标的速度，建议设置到 <code>6~8</code> 左右，不然移动速度太快了，可以根据自己需求来调，我自己设置速度为 <code>7</code> 。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">defaults write -g com.apple.mouse.scaling 7</span><br></pre></td></tr></table></figure><ul><li>然后重启电脑，必须要重启电脑以后设置才会生效，而且生效以后就不要再去设置里面调鼠标速度了，不然会还原覆盖掉之前改的速度。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;买了一个 &lt;code&gt;Magic Mouse&lt;/code&gt; 之后发现移动速度比之前鼠标要慢好多，设置里已经设置到最快了还是很慢，非常不习惯，最后查到可以在终端里输入命令调整 &lt;code&gt;Magic Mouse&lt;/code&gt; 的移动速度，下面记录一下方法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Mac 使用指南" scheme="https://karise.cn/categories/Mac-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="Mac 使用指南" scheme="https://karise.cn/tags/Mac-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    <category term="Magic Mouse" scheme="https://karise.cn/tags/Magic-Mouse/"/>
    
  </entry>
  
  <entry>
    <title>【iOS 开发】利用 iTunes 接口检查 App 版本更新</title>
    <link href="https://karise.cn/2018/01/18/iOS/201801181428/"/>
    <id>https://karise.cn/2018/01/18/iOS/201801181428/</id>
    <published>2018-01-18T06:28:05.000Z</published>
    <updated>2023-02-28T03:16:29.917Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>iOS</code> 想要检查 <code>App</code> 当前版本是否为最新，一般的方案大概都是服务器自己提供一个接口来获取 <code>App</code> 最新版本是多少，然后再做出相应提示是否需要更新，但是接口需要手动维护，应用要审核，还得等审核通过以后才能更新版本号，其实苹果提供了一个 <code>iTunes</code> 接口，能够查到 <code>App</code> 在 <code>AppStore</code> 上的状态信息，既省事又准确，下面记录一下具体实现方法。</p></blockquote><a id="more"></a><hr><h2 id="接口信息"><a href="#接口信息" class="headerlink" title="接口信息"></a>接口信息</h2><ul><li>这是 <a href="http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html">iTunes 接口地址</a> ，有兴趣可以看一下，我们要用到的接口如下，<code>xxx</code> 处换成自己 <code>App</code> 的 <code>AppId</code> ，<code>AppId</code> 可以在 <code>iTunes Connect</code> 里面看到。</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://itunes.apple.com/lookup?id=xxx</span><br></pre></td></tr></table></figure><ul><li>接口返回的内容有很多，我就挑一些有用的截出来了。</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;resultCount&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;results&quot;</span> : [&#123;</span><br><span class="line">        <span class="string">&quot;artistId&quot;</span> : <span class="string">&quot;开发者 ID&quot;</span>,</span><br><span class="line">        <span class="string">&quot;artistName&quot;</span> : <span class="string">&quot;开发者名称&quot;</span>,</span><br><span class="line">        <span class="string">&quot;trackCensoredName&quot;</span> : <span class="string">&quot;审查名称&quot;</span>,</span><br><span class="line">        <span class="string">&quot;trackContentRating&quot;</span> : <span class="string">&quot;评级&quot;</span>,</span><br><span class="line">        <span class="string">&quot;trackId&quot;</span> : <span class="string">&quot;应用程序 ID&quot;</span>,</span><br><span class="line">        <span class="string">&quot;trackName&quot;</span> = <span class="string">&quot;应用程序名称&quot;</span>,</span><br><span class="line">        <span class="string">&quot;trackViewUrl&quot;</span> = <span class="string">&quot;应用程序下载网址&quot;</span>,</span><br><span class="line">        <span class="string">&quot;userRatingCount&quot;</span> = <span class="string">&quot;用户评论数量&quot;</span>,</span><br><span class="line">        <span class="string">&quot;userRatingCountForCurrentVersion&quot;</span> = <span class="string">&quot;当前版本的用户评论数量&quot;</span>,</span><br><span class="line">        <span class="string">&quot;version&quot;</span> = <span class="string">&quot;版本号&quot;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>下面是检查版本更新的具体实现方法，注意接口地址 <code>xxx</code> 处换成自己 <code>App</code> 的 <code>AppId</code> ，<code>App</code> 审核的时候版本肯定是比 <code>AppStore</code> 上高的，所以不用担心审核时会跳出更新提示。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 检查版本更新</span></span><br><span class="line">- (<span class="keyword">void</span>)checkVersion &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *url = <span class="string">@&quot;http://itunes.apple.com/lookup?id=xxx&quot;</span>;</span><br><span class="line">    [[AFHTTPSessionManager manager] POST:url parameters:<span class="literal">nil</span> progress:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> responseObject) &#123;</span><br><span class="line">        DLog(<span class="string">@&quot;版本更新检查成功&quot;</span>);</span><br><span class="line">        <span class="built_in">NSArray</span> *results = responseObject[<span class="string">@&quot;results&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (results &amp;&amp; results.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *response = results.firstObject;</span><br><span class="line">            <span class="built_in">NSString</span> *currentVersion = [[<span class="built_in">NSBundle</span> mainBundle] objectForInfoDictionaryKey:<span class="string">@&quot;CFBundleShortVersionString&quot;</span>]; <span class="comment">// 软件的当前版本</span></span><br><span class="line">            <span class="built_in">NSString</span> *lastestVersion = response[<span class="string">@&quot;version&quot;</span>]; <span class="comment">// AppStore 上软件的最新版本</span></span><br><span class="line">            <span class="keyword">if</span> (currentVersion &amp;&amp; lastestVersion &amp;&amp; ![<span class="keyword">self</span> isLastestVersion:currentVersion compare:lastestVersion]) &#123;</span><br><span class="line">                <span class="comment">// 给出提示是否前往 AppStore 更新</span></span><br><span class="line">                <span class="built_in">UIAlertController</span> *alert = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@&quot;提示&quot;</span> message:<span class="string">@&quot;检测到有版本更新，是否前往 AppStore 更新版本。&quot;</span> preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>];</span><br><span class="line">                [alert addAction:[<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@&quot;前往&quot;</span> style:<span class="built_in">UIAlertActionStyleDefault</span> handler:^(<span class="built_in">UIAlertAction</span> *action) &#123;</span><br><span class="line">                    <span class="built_in">NSString</span> *trackViewUrl = response[<span class="string">@&quot;trackViewUrl&quot;</span>]; <span class="comment">// AppStore 上软件的地址</span></span><br><span class="line">                    <span class="keyword">if</span> (trackViewUrl) &#123;</span><br><span class="line">                        <span class="built_in">NSURL</span> *appStoreURL = [<span class="built_in">NSURL</span> URLWithString:trackViewUrl];</span><br><span class="line">                        <span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:appStoreURL]) &#123;</span><br><span class="line">                            [[<span class="built_in">UIApplication</span> sharedApplication] openURL:appStoreURL];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;]];</span><br><span class="line">                [alert addAction:[<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@&quot;取消&quot;</span> style:<span class="built_in">UIAlertActionStyleCancel</span> handler:<span class="literal">nil</span>]];</span><br><span class="line">                [<span class="keyword">self</span>.window.rootViewController presentViewController:alert animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        DLog(<span class="string">@&quot;版本更新检查失败&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 判断是否最新版本号（大于或等于为最新）</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isLastestVersion:(<span class="built_in">NSString</span> *)currentVersion compare:(<span class="built_in">NSString</span> *)lastestVersion &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentVersion &amp;&amp; lastestVersion) &#123;</span><br><span class="line">        <span class="comment">// 拆分成数组</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *currentItems = [[currentVersion componentsSeparatedByString:<span class="string">@&quot;.&quot;</span>] mutableCopy];</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *lastestItems = [[lastestVersion componentsSeparatedByString:<span class="string">@&quot;.&quot;</span>] mutableCopy];</span><br><span class="line">        <span class="comment">// 如果数量不一样补0</span></span><br><span class="line">        <span class="built_in">NSInteger</span> currentCount = currentItems.count;</span><br><span class="line">        <span class="built_in">NSInteger</span> lastestCount = lastestItems.count;</span><br><span class="line">        <span class="keyword">if</span> (currentCount != lastestCount) &#123;</span><br><span class="line">            <span class="built_in">NSInteger</span> count = labs(currentCount - lastestCount); <span class="comment">// 取绝对值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentCount &gt; lastestCount) &#123;</span><br><span class="line">                    [lastestItems addObject:<span class="string">@&quot;0&quot;</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    [currentItems addObject:<span class="string">@&quot;0&quot;</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 依次比较</span></span><br><span class="line">        <span class="built_in">BOOL</span> isLastest = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currentItems.count; ++i) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *currentItem = currentItems[i];</span><br><span class="line">            <span class="built_in">NSString</span> *lastestItem = lastestItems[i];</span><br><span class="line">            <span class="keyword">if</span> (currentItem.integerValue != lastestItem.integerValue) &#123;</span><br><span class="line">                isLastest = currentItem.integerValue &gt; lastestItem.integerValue;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isLastest;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;iOS&lt;/code&gt; 想要检查 &lt;code&gt;App&lt;/code&gt; 当前版本是否为最新，一般的方案大概都是服务器自己提供一个接口来获取 &lt;code&gt;App&lt;/code&gt; 最新版本是多少，然后再做出相应提示是否需要更新，但是接口需要手动维护，应用要审核，还得等审核通过以后才能更新版本号，其实苹果提供了一个 &lt;code&gt;iTunes&lt;/code&gt; 接口，能够查到 &lt;code&gt;App&lt;/code&gt; 在 &lt;code&gt;AppStore&lt;/code&gt; 上的状态信息，既省事又准确，下面记录一下具体实现方法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="iOS 开发" scheme="https://karise.cn/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS 开发" scheme="https://karise.cn/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
    <category term="版本更新" scheme="https://karise.cn/tags/%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用 Vultr 搭建 SSR 服务器的方法</title>
    <link href="https://karise.cn/2018/01/06/Other/201801061653/"/>
    <id>https://karise.cn/2018/01/06/Other/201801061653/</id>
    <published>2018-01-06T08:53:30.000Z</published>
    <updated>2023-02-28T03:20:29.661Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>身为一个开发人员由于经常要用到谷歌，所以访问外网是不可避免的，但是由于网上大多数 <code>SS</code> 账号都被封了，于是决定自己搭建一个服务器，价格也不贵而且也方便管理，这里就记录一下搭建方法。</p></blockquote><a id="more"></a><hr><h2 id="1-购买-VPS-服务器"><a href="#1-购买-VPS-服务器" class="headerlink" title="1. 购买 VPS 服务器"></a>1. 购买 VPS 服务器</h2><ul><li><p>首先前往 <a href="https://my.vultr.com/">Vultr</a> 官网注册一个账号。</p></li><li><p>我这边使用的服务器价格花费是 <code>$5.0</code> 一个月，折合 <code>RMB</code> 大概 <code>34</code> 块左右，现在 <code>$2.5</code> 美元一个月的服务器配置已经不支持 <code>IPV4</code> 了，所以最低只能用 <code>$5.0</code> 一个月的了。</p></li><li><p>虽然是 <code>$5.0</code> 一个月，但是 <code>Vultr</code> 的服务器实际是按小时扣费的，这样的好处就是可以随时更换服务器，反正是按小时扣费的。</p></li><li><p>部署服务器之前，需要先充钱到账户里，选择左侧菜单中的 <code>Billing</code> ，<code>Vultr</code> 已经支持支付宝支付了，选择 <code>Alipay</code> 然后充值最低金额 <code>$10</code> 就行了，折合 <code>RMB</code> 大概 <code>65</code> 块左右。</p></li></ul><p><img data-src="https://file.karise.cn/blog/20190509172623.jpg"></p><ul><li>充值完以后，就可以开始购买 <code>VPS</code> 服务器了，选择左侧菜单中的 <code>Servers</code> ，选择右上角的 <code>+</code> 前往服务器选择页面。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509172635.jpg"></p><ul><li>选择一个服务器的地区，这里可以根据自己的需求选择，建议选择 <code>日本(Tokyo)</code> 或 <code>新加坡(Singapore)</code> ，因为离我们比较近可能速度会快一点，我这里选择的是 <code>New York (NJ)</code> 。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509172647.jpg"></p><ul><li>然后选择 <code>CentOS 6 x64</code> 系统，这里要注意是 <code>6 x64</code> ，不要选择 <code>7 x64</code> ，<code>CentOS 7</code> 默认的防火墙可能会干扰 <code>SSR</code> 的正常连接！（点击 <code>7 x64</code> 的文字就可以切换成 <code>6 x64</code>）</li></ul><p><img data-src="https://file.karise.cn/blog/20190509172700.jpg"></p><ul><li>然后选择系统配置，这里要选择 <code>$5.0</code> 一个月的配置，<code>$2.5</code> 一个月的配置已经不支持 <code>IPV4</code> 了，所以用不了。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509172711.jpg"></p><ul><li>然后附加功能里除了收费选，其他全部选中。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509172722.jpg"></p><ul><li>最后选择 <code>Deploy Now</code> 开始部署服务器。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509172733.jpg"></p><h2 id="2-部署-VPS-服务器"><a href="#2-部署-VPS-服务器" class="headerlink" title="2. 部署 VPS 服务器"></a>2. 部署 VPS 服务器</h2><ul><li>部署完成后就可以在 <code>Servers</code> 里面看到你部署好的服务器了，点击 <code>Manage</code> 查看服务器信息。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509172748.jpg"></p><ul><li>在这里可以查看到服务器的所有信息，记下服务器的 <code>IP</code> 和 <code>密码</code>。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509172802.jpg"></p><ul><li>然后开始连接服务器，打开终端输入以下命令连接到服务器，<code>xxx</code> 处替换成你服务器的 <code>IP</code> 地址（我这里用的是 <code>mac</code> 系统，就只说 <code>mac</code> 系统的连接方法了，<code>windows</code> 系统的话可以用 <code>Xshell</code> 这个软件来连接，可以看 <a href="https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B">这篇文章</a> ）。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh root@xxx</span><br></pre></td></tr></table></figure><ul><li>接着将服务器密码粘贴上去回车即可连接，连接成功后依次输入以下命令来安装 <code>ShadowsocksR</code> 。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum -y install wget</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure><ul><li>出现以下界面后，输入 <code>1</code> 然后回车开始安装 <code>ShadowsocksR</code>（如果没有出现以下界面，说明上面地址失效了，网上重新找一个 <code>SSR</code> 安装脚本地址即可）。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509172817.jpg"></p><ul><li><p>接着根据提示输入内容，<code>端口号</code> 和 <code>密码</code> 输入自己想要的即可，如果就想用默认的直接回车即可。</p></li><li><p><code>加密方式</code> 可以选择 <code>aes-256-cfb</code> 。</p></li><li><p><code>协议插件</code> 我这边使用的是 <code>origin</code> ，接着会提示 <code>是否设置协议插件兼容原版</code> ，这里的原版指的是 <code>SS</code> 客户端，这里选择 <code>y</code> 。</p></li><li><p><code>混淆插件</code> 可以选择使用默认的，但是有的地区需要把混淆设置成 <code>plain</code> 才好用，因为混淆不总是有效果，要看各地区策略的，我这边选择的是 <code>plain</code> ，然后 <code>兼容原版</code> 同上。</p></li><li><p>之后会依次提示你对 <code>设备数</code> 、<code>单线程限速</code> 和 <code>端口总限速</code> 进行设置，默认值是 <code>无限</code> ，个人使用的话，选择默认值即可，直接敲回车键。</p></li><li><p>之后代码就正式自动部署了，会提示你下载文件，输入 <code>y</code> 开始部署。</p></li><li><p>最后出现如下界面表示部署成功，界面中会显示你的 <code>SSR</code> 账号信息。</p></li></ul><p><img data-src="https://file.karise.cn/blog/20190509172828.jpg"></p><ul><li>之后如果还想查看 <code>SSR</code> 账号信息的话，输入以下命令即可。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bash ssr.sh</span><br></pre></td></tr></table></figure><h2 id="3-加速-VPS-服务器"><a href="#3-加速-VPS-服务器" class="headerlink" title="3. 加速 VPS 服务器"></a>3. 加速 VPS 服务器</h2><p>此加速为谷歌 <code>BBR</code> 加速，<code>Vultr</code> 的服务器框架可以装 <code>BBR</code> 加速，加速后对速度的提升很明显，所以推荐部署加速脚本，该加速方法是开机自动启动，部署一次就可以了。</p><ul><li>依旧是在服务器环境下，输入以下命令开始部署 <code>BBR</code> 加速。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; bash bbr.sh</span><br></pre></td></tr></table></figure><ul><li>接着会提示让你按下任意键开始部署，然后等待自动部署完成即可，成功后会出现 <code>Complete!</code> ，接着输入 <code>y</code> 重启服务器即可。</li></ul><h2 id="4-SSR-客户端下载"><a href="#4-SSR-客户端下载" class="headerlink" title="4. SSR 客户端下载"></a>4. SSR 客户端下载</h2><p>配置完以后就可以使用 <code>SSR</code> 客户端来尝试是否能访问 <a href="https://www.google.com/">Google</a>，还有一点要注意如果要用 <code>SS</code> 客户端的话，上面配置中的 <code>协议</code> 必须为 <code>origin</code> ，混淆必须为 <code>plain</code> ，这样就可以使用 <code>SS</code> 客户端了（即 <code>协议</code> 和 <code>混淆</code> 可以不填）。</p><ul><li><p><code>Mac</code> 版 <code>SSR</code> 客户端 <a href="https://github.com/shadowsocksr-backup/ShadowsocksX-NG/releases">下载地址</a>、<a href="https://nofile.io/f/jgMWFwCBonU#ab0d3c3b6ac54482">备用下载地址</a>。</p></li><li><p><code>Windows</code> 版 <code>SSR</code> 客户端 <a href="https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases">下载地址</a>、<a href="https://nofile.io/f/6Jm7WJCyOVv/ShadowsocksR-4.7.0-win.7z">备用下载地址</a>。</p></li><li><p><code>Android</code> 版 <code>SSR</code> 客户端 <a href="https://github.com/shadowsocksr-backup/shadowsocksr-android/releases/download/3.4.0.8/shadowsocksr-release.apk">下载地址</a>、<a href="https://nofile.io/f/rvTJoj0h5GC/shadowsocksr-release.apk">备用下载地址</a>。</p></li><li><p><code>iOS</code> 版 <code>SSR</code> 客户端：<code>Potatso Lite</code>、<code>Potatso</code>、<code>shadowrocket</code> 都可以作为 <code>SSR</code> 客户端，但这些软件目前已经在国内的 <code>App Store</code> 下架，可以用美区的 <code>AppID</code> 账号来下载，国内的话可以用 <code>SuperWingy</code>，但这是 <code>SS</code> 客户端，不支持 <code>SSR</code>。</p></li></ul><blockquote><p>过程还是比较简单的，都是无脑一键部署的，本文参考地址：<a href="https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B">自建ss服务器教程</a> ，有不懂的地方也可以看看这篇文章。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;身为一个开发人员由于经常要用到谷歌，所以访问外网是不可避免的，但是由于网上大多数 &lt;code&gt;SS&lt;/code&gt; 账号都被封了，于是决定自己搭建一个服务器，价格也不贵而且也方便管理，这里就记录一下搭建方法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="其他相关" scheme="https://karise.cn/categories/%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Vultr" scheme="https://karise.cn/tags/Vultr/"/>
    
    <category term="SS" scheme="https://karise.cn/tags/SS/"/>
    
    <category term="SSR" scheme="https://karise.cn/tags/SSR/"/>
    
    <category term="Shadowsocks" scheme="https://karise.cn/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>【iOS 开发】导航栏各种右滑返回失效的解决方法</title>
    <link href="https://karise.cn/2017/12/12/iOS/201712121005/"/>
    <id>https://karise.cn/2017/12/12/iOS/201712121005/</id>
    <published>2017-12-12T02:05:35.000Z</published>
    <updated>2023-02-28T03:16:23.782Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>iOS</code> 的几乎全部页面都是需要右滑返回的，否则用户体验会大打折扣，但是在开发过程中经常会碰到某些页面右滑返回失效的情况，下面记录一下各种情况下右滑返回失效的解决方法。</p></blockquote><a id="more"></a><hr><h3 id="自定义返回按钮时失效"><a href="#自定义返回按钮时失效" class="headerlink" title="自定义返回按钮时失效"></a>自定义返回按钮时失效</h3><ul><li>当你重写 <code>self.navigationItem.leftBarButtonItem</code> 之后，自带的返回按钮就会被覆盖，右滑返回就会失效，解决办法只要加入下面这句代码即可。</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.navigationController.interactivePopGestureRecognizer.delegate = <span class="keyword">self</span>; <span class="comment">// 解决右滑返回失效问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后你可以使用下面这句代码来控制是否允许右滑返回，这句代码要加在 <code>viewDidAppear</code> 里面，否则多个页面切换时会出现异常。</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.navigationController.interactivePopGestureRecognizer setEnabled:_isShowBackButton]; <span class="comment">// 是否允许右滑返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UIScrollView-页面中失效"><a href="#UIScrollView-页面中失效" class="headerlink" title="UIScrollView 页面中失效"></a>UIScrollView 页面中失效</h3><ul><li>当使用 <code>UIScrollView</code> 、<code>UITableView</code> 、<code>UICollectionView</code> 等滑动视图的左右滑动时，滑动手势就会和右滑返回的手势冲突，右滑返回就会失效，解决办法只要加入下面这句代码即可。</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决右滑返回失效的问题</span></span><br><span class="line">[scrollView.panGestureRecognizer requireGestureRecognizerToFail:<span class="keyword">self</span>.navigationController.interactivePopGestureRecognizer];</span><br></pre></td></tr></table></figure><h3 id="UIWebView-页面中失效"><a href="#UIWebView-页面中失效" class="headerlink" title="UIWebView 页面中失效"></a>UIWebView 页面中失效</h3><ul><li><code>UIWebView</code> 页面比较特殊，不仅右滑返回会失效，自定义的手势也会全部失效，因为 <code>UIWebView</code> 中已经内部集成了点击、滑动等多个手势，上面的方法在 <code>UIWebView</code> 中并没有作用，解决办法是加入以下允许多个手势并发的代理方法。</li></ul><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 允许多个手势并发</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;iOS&lt;/code&gt; 的几乎全部页面都是需要右滑返回的，否则用户体验会大打折扣，但是在开发过程中经常会碰到某些页面右滑返回失效的情况，下面记录一下各种情况下右滑返回失效的解决方法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="iOS 开发" scheme="https://karise.cn/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS 开发" scheme="https://karise.cn/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
    <category term="iOS 开发问题" scheme="https://karise.cn/tags/iOS-%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    
    <category term="导航栏" scheme="https://karise.cn/tags/%E5%AF%BC%E8%88%AA%E6%A0%8F/"/>
    
    <category term="右滑返回失效" scheme="https://karise.cn/tags/%E5%8F%B3%E6%BB%91%E8%BF%94%E5%9B%9E%E5%A4%B1%E6%95%88/"/>
    
  </entry>
  
  <entry>
    <title>mac 终端使用自动补全时忽略大小写的方法</title>
    <link href="https://karise.cn/2017/12/06/Mac/201712061436/"/>
    <id>https://karise.cn/2017/12/06/Mac/201712061436/</id>
    <published>2017-12-06T06:36:53.000Z</published>
    <updated>2023-02-28T03:18:07.134Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>mac</code> 终端在使用 <code>tab</code> 补全路径时是默认大小写敏感的，以下方法可以忽略大小写，方法同样适用于 <code>iTerm2</code> 。</p></blockquote><a id="more"></a><hr><ul><li>打开终端输入以下命令。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nano .inputrc</span><br></pre></td></tr></table></figure><ul><li>接着将以下命令复制进去。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> completion-ignore-case on</span><br><span class="line"><span class="built_in">set</span> show-all-if-ambiguous on</span><br><span class="line">TAB: menu-complete</span><br></pre></td></tr></table></figure><p><img data-src="https://file.karise.cn/blog/20190509163847.png" alt="终端"></p><ul><li><p>然后按下 <code>control + O</code> 之后回车保存，重启终端即可（注意是 <code>control</code> 不是 <code>command</code>）。</p></li><li><p>终端重启后，就会发现已经忽略大小写了。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;mac&lt;/code&gt; 终端在使用 &lt;code&gt;tab&lt;/code&gt; 补全路径时是默认大小写敏感的，以下方法可以忽略大小写，方法同样适用于 &lt;code&gt;iTerm2&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Mac 使用指南" scheme="https://karise.cn/categories/Mac-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="macOS" scheme="https://karise.cn/tags/macOS/"/>
    
    <category term="终端" scheme="https://karise.cn/tags/%E7%BB%88%E7%AB%AF/"/>
    
    <category term="iTerm2" scheme="https://karise.cn/tags/iTerm2/"/>
    
  </entry>
  
  <entry>
    <title>mac 删除 Windows 或 EFI Boot 启动盘的方法</title>
    <link href="https://karise.cn/2017/11/21/Mac/201711211402/"/>
    <id>https://karise.cn/2017/11/21/Mac/201711211402/</id>
    <published>2017-11-21T06:02:49.000Z</published>
    <updated>2023-02-28T03:18:02.161Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于我的 <code>mac</code> 之前装了 <code>Windows</code> 双系统，然后 <code>mac</code> 系统升级后，我想把 <code>Windows</code> 系统给删掉，但是发现升级 <code>mac</code> 系统以后不能用 <code>Boot Camp</code> 删除 <code>Windows</code> 了，然后我就用 <code>磁盘工具</code> 把 <code>Windows</code> 分区给删除合并到 <code>mac</code> 分区了，但是发现系统虽然删除了，但是开机按住 <code>option</code> 键还是会出现 <code>Windows</code> 启动盘，虽然没什么影响但是强迫症当然不能忍 ，下面就记录一下解决方法。</p></blockquote><a id="more"></a><hr><p><img data-src="https://file.karise.cn/blog/20190509163832.jpg" alt="启动界面"></p><ul><li>因为以下命令需要 <code>root</code> 用户执行，所以打开终端执行以下命令切换到 <code>root</code> 用户，输入密码后回车即可。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo -i</span><br></pre></td></tr></table></figure><ul><li>接着在终端执行以下命令，作用是在 <code>Macintosh HD</code> 根目录新建一个目录 <code>mnt</code> 。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir /mnt</span><br></pre></td></tr></table></figure><ul><li>接着在终端执行以下命令，作用是将该 <code>windows</code> 盘挂在到 <code>/mnt</code> 目录下。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo mount -t msdos /dev/disk0s1 /mnt</span><br></pre></td></tr></table></figure><ul><li><p>打开 <code>Finder</code> ，在 <code>Macintosh HD</code> 根目录会看到一个叫 <code>EFI</code> 的磁盘（桌面应该也会显示这个磁盘，和 <code>Finder</code> 置有关）。</p></li><li><p>打开 <code>EFI</code> 磁盘，这里要说一下，如果你只想删除 <code>Windows</code> 启动盘，可以找到有个 <code>Microsoft</code> 文件夹删除即可，但是如果只删除这个的话，开机还是会显示一个叫 <code>EFI Boot</code> 的启动盘，个人建议将 <code>EFI</code> 磁盘里面的东西全部删除，这样 <code>Windows</code> 和 <code>EFI Boot</code> 启动盘就都没了，亲测有效无副作用。</p></li><li><p>删除以后清空废纸篓然后把 <code>EFI</code> 磁盘推出，然后重启按住 <code>option</code> 键检验是否删除。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;由于我的 &lt;code&gt;mac&lt;/code&gt; 之前装了 &lt;code&gt;Windows&lt;/code&gt; 双系统，然后 &lt;code&gt;mac&lt;/code&gt; 系统升级后，我想把 &lt;code&gt;Windows&lt;/code&gt; 系统给删掉，但是发现升级 &lt;code&gt;mac&lt;/code&gt; 系统以后不能用 &lt;code&gt;Boot Camp&lt;/code&gt; 删除 &lt;code&gt;Windows&lt;/code&gt; 了，然后我就用 &lt;code&gt;磁盘工具&lt;/code&gt; 把 &lt;code&gt;Windows&lt;/code&gt; 分区给删除合并到 &lt;code&gt;mac&lt;/code&gt; 分区了，但是发现系统虽然删除了，但是开机按住 &lt;code&gt;option&lt;/code&gt; 键还是会出现 &lt;code&gt;Windows&lt;/code&gt; 启动盘，虽然没什么影响但是强迫症当然不能忍 ，下面就记录一下解决方法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Mac 使用指南" scheme="https://karise.cn/categories/Mac-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="mac" scheme="https://karise.cn/tags/mac/"/>
    
    <category term="Windows" scheme="https://karise.cn/tags/Windows/"/>
    
    <category term="Mac 使用指南" scheme="https://karise.cn/tags/Mac-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    <category term="EFI Boot" scheme="https://karise.cn/tags/EFI-Boot/"/>
    
    <category term="启动盘" scheme="https://karise.cn/tags/%E5%90%AF%E5%8A%A8%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>【iOS 开发】使用 Jenkins + Fastlane 持续集成 iOS 项目</title>
    <link href="https://karise.cn/2017/11/13/iOS/201711131450/"/>
    <id>https://karise.cn/2017/11/13/iOS/201711131450/</id>
    <published>2017-11-13T06:50:53.000Z</published>
    <updated>2023-02-28T03:16:19.493Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持续集成（<a href="http://martinfowler.com/articles/continuousIntegration.html">Continuous Integration</a> 简称 <code>CI</code>）。<a href="https://jenkins.io/">Jenkins</a> 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。具体就不多说了，想要更多的了解可以去查一下，下面是集成方法。</p></blockquote><a id="more"></a><hr><p><strong>本文最终目的：</strong></p><ul><li>测试人员可登录 <code>Jenkins</code> 网页自行选择 <code>开发分支</code> 和 <code>打包类型</code> ，然后自动打包完成并自动上传至 <code>蒲公英</code> 或 <code>iTunes Connect</code> ，不再需要开发人员手动安装或上传。</li></ul><h2 id="1-配置-Fastlane"><a href="#1-配置-Fastlane" class="headerlink" title="1. 配置 Fastlane"></a>1. 配置 Fastlane</h2><p>由于项目的编译打包以及上传全部要依赖 <code>Fastlane</code> 来进行，所以在配置 <code>Jenkins</code> 之前要保证项目已经配置好了 <code>Fastlane</code> ，这里看我的另一篇文章：<a href="http://www.jianshu.com/p/662677cb1b47">【iOS 开发】使用 Fastlane 自动化打包并发布 iOS 项目</a> 。</p><h2 id="2-安装-Jenkins"><a href="#2-安装-Jenkins" class="headerlink" title="2. 安装 Jenkins"></a>2. 安装 Jenkins</h2><ul><li><p><code>Jenkins</code> 依赖于 <code>Java</code> 运行环境，因此需要先保证电脑已经安装了 <code>Java JDK</code> ，如果没有的话前往 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">这里</a> 下载安装即可。</p></li><li><p>我这里是使用 <a href="https://brew.sh/">homebrew</a> 安装 <code>Jenkins</code> ，没有安装 <code>homebrew </code> 的输入以下命令安装一下。</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>千万不要去 <code>Jenkins</code> 官网下载 <code>pkg</code> 安装包安装，因为用安装包安装会自动生成一个共享用户 <code>jenkins</code>，而这个用户的权限和系统登录用户的权限不同，会造成大量的权限问题，我已经被坑惨了，用 <code>homebrew </code> 装是不会生成共享用户的。</p></li><li><p><code>homebrew</code> 安装完成后输入以下命令安装 <code>Jenkins</code> 。</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install jenkins</span><br></pre></td></tr></table></figure><p><img data-src="https://file.karise.cn/blog/20190509165227.png" alt="安装"></p><ul><li>如果想要卸载直接执行以下命令即可卸载 <code>Jenkins</code> 。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew uninstall jenkins</span><br></pre></td></tr></table></figure><ul><li>安装完成后输入以下命令链接 <code>launchd</code> 配置文件。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ln -sfv /usr/<span class="built_in">local</span>/opt/jenkins/*.plist ~/Library/LaunchAgents</span><br></pre></td></tr></table></figure><ul><li>然后执行以下命令启动 <code>Jenkins</code> 。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</span><br></pre></td></tr></table></figure><ul><li><code>Jenkins</code> 默认是开机自动启动的，如果想关闭就执行以下命令即可关闭。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</span><br></pre></td></tr></table></figure><ul><li>接着打开浏览器，输入 <a href="http://localhost:8080/">http://localhost:8080</a> ，就可以看到 <code>Jenkins</code> 已经启动。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509165242.png" alt="Jenkins"></p><ul><li><code>Jenkins</code> 默认端口号是 <code>8080</code> ，如果想要更改端口号的话可以用 <code>Xcode</code> 打开以下文件，将 <code>httpPort</code> 后面的 <code>8080</code> 改成你想要的端口号即可。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/opt/jenkins/homebrew.mxcl.jenkins.plist</span><br></pre></td></tr></table></figure><p><img data-src="https://file.karise.cn/blog/20190509165253.png" alt="修改端口"></p><h2 id="3-配置-Jenkins"><a href="#3-配置-Jenkins" class="headerlink" title="3. 配置 Jenkins"></a>3. 配置 Jenkins</h2><ul><li>等待启动完成后 ，会出现以下界面让你输入密码解锁。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509165307.png" alt="Jenkins"></p><ul><li>密码就在上面提示的 <code>/Users/Jonzzs/.jenkins/secrets/initialAdminPassword</code> 文件中，打开 <code>initialAdminPassword</code> 文件将密码复制到浏览器解锁即可，然后点击第一个 <code>Install suggested plugins</code>。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509165322.png" alt="Jenkins"></p><ul><li>然后等待插件全部安装完成。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509165344.png" alt="Jenkins"></p><ul><li>安装完成后会跳出创建用户界面，按照提示创建用户即可。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509165359.png" alt="Jenkins"></p><ul><li>最后到这个页面就算是安装完成了。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509165414.png" alt="Jenkins"></p><h2 id="4-安装插件"><a href="#4-安装插件" class="headerlink" title="4. 安装插件"></a>4. 安装插件</h2><ul><li>在建任务之前需要先安装几个插件，前往 <code>系统管理</code> - <code>管理插件</code> ，在 <code>可选插件</code> 中搜索 <code>GitLab Plugin</code> 、<code>Gitlab Hook Plugin</code> 、<code>Xcode integration</code> 这三个插件，然后安装。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509165429.png" alt="Jenkins"></p><h2 id="5-配置环境变量"><a href="#5-配置环境变量" class="headerlink" title="5. 配置环境变量"></a>5. 配置环境变量</h2><ul><li>前往 <code>系统管理</code> - <code>系统设置</code> 找到 <code>全局属性</code> ，然后添加以下三个环境变量。</li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">LANG</span></span><br><span class="line"><span class="attr">en_US.UTF-8</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">LANGUAGE</span></span><br><span class="line"><span class="attr">en_US.UTF-8</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">LC_ALL</span></span><br><span class="line"><span class="attr">en_US.UTF-8</span></span><br></pre></td></tr></table></figure><p><img data-src="https://file.karise.cn/blog/20190509165443.png" alt="环境变量"></p><ul><li>这三个环境变量是用来修改编码格式的，如果不加下面脚本执行 <code>fastlane</code> 命令时会报错。</li></ul><h2 id="6-创建任务"><a href="#6-创建任务" class="headerlink" title="6. 创建任务"></a>6. 创建任务</h2><ul><li>插件安装完成以后就可以开始创建项目了，点击新建任务，输入你的项目名称。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509165455.png" alt="Jenkins"></p><ul><li>勾选 <code>参数化构建过程</code> ，添加一个 <code>String Parameter</code> 和一个 <code>Choice Parameter</code> ，第一个 <code>ARCHIVE_BRANCH</code> 主要是输入要打包的项目分支，第二个 <code>ARCHIVE_TYPE</code> 是选择打包的类型，我这边 <code>beta</code> 是打包发布到 <code>蒲公英</code> ，<code>release</code> 是打包发布到 <code>iTunes Connect</code> ，如果你不需要这些参数可以跳过。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509165507.png" alt="Jenkins"></p><ul><li>在 <code>源码管理</code> 输入你的仓库地址，地址为 <code>SSH</code> 方式，然后需要在点击 <code>Add</code> 添加 <code>SSH Key</code> 。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509165518.png" alt="Jenkins"></p><ul><li><p>选择 <code>SSH Username with private key</code> 类型，<code>Username</code> 随便填，然后选择 <code>Enter directly</code> ，将自己 <code>SSH Key</code> 的私钥复制进去即可，注意是私钥不是公钥，<code>/Users/Jonzzs/.ssh/id_rsa</code> 在这个文件里。</p></li><li><p>如果自己电脑没有生成过 <code>SSH Key</code> ，就自己去查一下吧，这里就不重复了。</p></li><li><p>最后在 <code>构建</code> 中增加一个 <code>Execute Shell</code> ，主要用来填写脚本内容。</p></li></ul><p><img data-src="https://file.karise.cn/blog/20190509165542.png" alt="Jenkins"></p><ul><li>填写以下脚本命令，<code>xxx</code> 处填写自己项目相应文件夹名，因为在执行 <code>fastlane</code> 指令之前需要进入 <code>fastlane</code> 文件夹所在目录，如果你的 <code>git</code> 根目录就是在项目目录的话，可以不用这句，然后点击 <code>保存</code> 即可。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout <span class="variable">$&#123;ARCHIVE_BRANCH&#125;</span></span><br><span class="line">git pull</span><br><span class="line"><span class="built_in">cd</span> ./xxx</span><br><span class="line">fastlane <span class="variable">$&#123;ARCHIVE_TYPE&#125;</span></span><br></pre></td></tr></table></figure><h2 id="7-开始打包"><a href="#7-开始打包" class="headerlink" title="7. 开始打包"></a>7. 开始打包</h2><ul><li>进入你创建的任务，点击 <code>Build with Parameters</code> ，然后输入要打包的项目分支以及类型，然后点击 <code>开始构建</code> 即可开始打包。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509165554.png" alt="Jenkins"></p><ul><li>如果构建失败，也可以在 <code>Build History</code> 中点击 <code>Console Output</code> 查看控制台输出记录，找到错误原因。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509165605.png" alt="Jenkins"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;持续集成（&lt;a href=&quot;http://martinfowler.com/articles/continuousIntegration.html&quot;&gt;Continuous Integration&lt;/a&gt; 简称 &lt;code&gt;CI&lt;/code&gt;）。&lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins&lt;/a&gt; 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。具体就不多说了，想要更多的了解可以去查一下，下面是集成方法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="iOS 开发" scheme="https://karise.cn/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS 开发" scheme="https://karise.cn/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
    <category term="Jenkins" scheme="https://karise.cn/tags/Jenkins/"/>
    
    <category term="Fastlane" scheme="https://karise.cn/tags/Fastlane/"/>
    
    <category term="持续集成" scheme="https://karise.cn/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    <category term="自动化打包" scheme="https://karise.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>【iOS 开发】使用 Fastlane 自动化打包并发布 iOS 项目</title>
    <link href="https://karise.cn/2017/11/09/iOS/201711091509/"/>
    <id>https://karise.cn/2017/11/09/iOS/201711091509/</id>
    <published>2017-11-09T07:09:54.000Z</published>
    <updated>2023-02-28T03:16:14.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Fastlane</code> 是一个完全开源的项目，是一款为 <code>iOS</code> 和 <code>Android</code> 开发者提供的自动化构建工具，它可以帮助开发者将 <code>App</code> 打包、签名、测试、发布、信息整理、提交 <code>App Store</code> 等工作完整的连接起来，实现完全自动化的工作流，如果使用得当，可以显著的提高开发者的开发效率，这是 <a href="https://github.com/fastlane/fastlane">GitHub 地址</a> 和 <a href="https://docs.fastlane.tools/">官方文档</a> 。</p></blockquote><a id="more"></a><hr><p><strong>本文最终目的：</strong></p><ul><li><p>终端输入 <code>fastlane beta</code> 自动打包 <code>ad-hoc</code> 版本的 <code>ipa</code> 包并自动上传到 <code>蒲公英</code> 。</p></li><li><p>终端输入 <code>fastlane release</code> 自动打包 <code>app-store</code> 版本的 <code>ipa</code> 包并自动上传到 <code>iTunes Connect</code> 。</p></li></ul><h2 id="1-安装-Fastlane"><a href="#1-安装-Fastlane" class="headerlink" title="1. 安装 Fastlane"></a>1. 安装 Fastlane</h2><ul><li>检查 <code>Ruby</code> 版本，需要 <code>2.0</code> 及以上版本，并且需要将 <code>gem</code> 的 <code>source</code> 改为 <code>https://gems.ruby-china.org/</code> ，在终端输入以下命令。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 查看 Ruby 版本</span><br><span class="line">ruby -v</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 查看 gem 的<span class="built_in">source</span></span><br><span class="line">gem sources</span><br></pre></td></tr></table></figure><ul><li>检查 <code>Xcode</code> 命令行工具是否安装，在终端输入以下命令，如果安装过会有提示，如果没装过就会自动开始安装。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><ul><li>开始安装 <code>Fastlane</code> ，在终端输入以下命令。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo gem install fastlane --verbose</span><br></pre></td></tr></table></figure><ul><li>如果安装时出现错误无法安装，就使用以下命令安装。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo gem install -n /usr/<span class="built_in">local</span>/bin fastlane</span><br></pre></td></tr></table></figure><ul><li>安装完成后可以输入以下命令查看版本来验证是否安装成功。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fastlane --version</span><br></pre></td></tr></table></figure><h2 id="2-安装蒲公英的-Fastlane-插件"><a href="#2-安装蒲公英的-Fastlane-插件" class="headerlink" title="2. 安装蒲公英的 Fastlane 插件"></a>2. 安装蒲公英的 Fastlane 插件</h2><ul><li><code>fastlane </code> 安装完成以后，在终端输入以下命令安装 <code>蒲公英</code> 插件。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fastlane add_plugin pgyer</span><br></pre></td></tr></table></figure><ul><li>最后出现 <code>Successfully installed plugins</code> 表示安装完成。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509163520.png" alt="插件安装"></p><ul><li>安装完成以后，会在系统根目录生成 <code>Gemfile</code> 和 <code>Gemfile.lock</code> 这两个文件，这两个文件不要删掉，不然插件就得重装了。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509163535.png" alt="Gemfile"></p><h2 id="3-修改项目配置"><a href="#3-修改项目配置" class="headerlink" title="3. 修改项目配置"></a>3. 修改项目配置</h2><ul><li>用 <code>Xcode</code> 打开你的项目，然后打开 <code>Manage Schemes...</code> 。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509163546.png" alt="Xcode"></p><ul><li>然后将工程的 <code>Scheme</code> 后面的 <code>Shared</code> 给勾上。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509163556.png" alt="Xcode"></p><ul><li>需要将这个改动上传到 <code>git</code> 仓库，不要忽略掉这个文件，提交的文件路径信息如下，如果你改完没有提示有需要改动的提交，那就看一下 <code>.gitignore</code> 里面是不是忽略掉了。</li></ul><p><img data-src="https://file.karise.cn/blog/20190509163608.png" alt="commit"></p><ul><li>做这个改动的原因是，后面可能会用到 <code>Jenkins</code> + <code>Fastlane</code> 做持续集成，如果没有这个文件，<code>Jenkins</code> 使用 <code>fastlane</code> 编译项目时会提示 <code>No schemes found in Xcode project or workspace</code> ，所以最好先加上。</li></ul><h2 id="4-初始化-Fastlane-配置"><a href="#4-初始化-Fastlane-配置" class="headerlink" title="4. 初始化 Fastlane 配置"></a>4. 初始化 Fastlane 配置</h2><ul><li>打开终端，<code>cd</code> 到你项目工程的根目录（<code>xcodeproj</code> 的同级目录），输入以下命令：</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fastlane init</span><br></pre></td></tr></table></figure><ul><li><p>初始化过程中会让你输入苹果开发者账号的账号和密码，这个信息会存储在钥匙串中，后续使用无需再输入密码。</p></li><li><p>初始化过程中还会检测当前项目的 <code>App Identifier</code> 是否已经在 <code>Apple Developer</code> 中，还会检测当前 <code>App</code> 是否已经在 <code>iTunes Connect</code> 中，如果都满足的话，过程应该是比较顺利的。</p></li><li><p>初始化完成之后会在你项目工程的目录下生成一个 <code>fastlane</code> 文件夹，里面是 <code>Fastlane</code> 的一些配置文件。其中 <code>Appfile</code> 里面存放了 <code>App</code> 的基本信息包括 <code>App_Identifier</code> 、<code>AppID</code> 、<code>Team_ID</code> 等。<code>Fastfile</code> 是最重要的一个文件，在这个文件里面可以编写和定制我们打包脚本的一个文件，所有自定义的功能都写在这里。</p></li></ul><h2 id="5-编辑-Fastlane-脚本文件"><a href="#5-编辑-Fastlane-脚本文件" class="headerlink" title="5. 编辑 Fastlane 脚本文件"></a>5. 编辑 Fastlane 脚本文件</h2><ul><li><p>首先找到工程目录下 <code>fastlane</code> 文件夹下的 <code>Fastlane</code> 文件，如果想要了解其中内容的含义可以自己去官方文档查一下，这里就不解释了。</p></li><li><p>使用编辑器打开 <code>Fastlane</code> 文件，将所有内容删除替换为以下内容。</p></li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">fastlane_version</span> <span class="string">&quot;xxx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">default_platform</span> :<span class="string">ios</span></span><br><span class="line"></span><br><span class="line"><span class="attr">platform</span> :<span class="string">ios do</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">desc</span> <span class="string">&quot;以 ad-hoc 方式打包并上传到蒲公英&quot;</span></span><br><span class="line">  <span class="attr">lane</span> :<span class="string">beta do</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">puts</span> <span class="string">&quot;自动生成 Provisioning Profiles 文件&quot;</span></span><br><span class="line">    <span class="attr">sigh(</span></span><br><span class="line"><span class="comment">      # 指定输出的文件夹地址</span></span><br><span class="line">      <span class="attr">output_path</span>: <span class="string">&quot;./archive/sign&quot;,</span></span><br><span class="line"><span class="comment">      # 是否为 AdHoc 证书（设为 false 或不写默认为 AppStore 证书）</span></span><br><span class="line">      <span class="attr">adhoc</span>: <span class="string">true</span></span><br><span class="line">    <span class="attr">)</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">puts</span> <span class="string">&quot;以 ad-hoc 方式打包&quot;</span></span><br><span class="line">    <span class="attr">gym(</span></span><br><span class="line"><span class="comment">      # 指定打包所使用的输出方式 (可选: app-store, package, ad-hoc, enterprise, development)</span></span><br><span class="line">      <span class="attr">export_method</span>: <span class="string">&quot;ad-hoc&quot;,</span></span><br><span class="line"><span class="comment">      # 指定项目的 scheme 名称</span></span><br><span class="line">      <span class="attr">scheme</span>: <span class="string">&quot;xxx&quot;,</span></span><br><span class="line"><span class="comment">      # 指定输出的文件夹地址</span></span><br><span class="line">      <span class="attr">output_directory</span>: <span class="string">&quot;./archive/beta/&quot; + Time.new.strftime(&quot;%Y-%m-%d-%H:%M:%S&quot;),</span></span><br><span class="line"><span class="comment">      # 指定打包方式 (可选: Release, Debug)</span></span><br><span class="line">      <span class="attr">configuration</span>: <span class="string">&quot;Release&quot;</span></span><br><span class="line">    <span class="attr">)</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">puts</span> <span class="string">&quot;上传 ipa 包到蒲公英&quot;</span></span><br><span class="line">    <span class="attr">pgyer(</span></span><br><span class="line"><span class="comment">      # 蒲公英 API KEY</span></span><br><span class="line">      <span class="attr">api_key</span>: <span class="string">&quot;xxx&quot;,</span></span><br><span class="line"><span class="comment">      # 蒲公英 USER KEY</span></span><br><span class="line">      <span class="attr">user_key</span>: <span class="string">&quot;xxx&quot;</span></span><br><span class="line">    <span class="attr">)</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">end</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">desc</span> <span class="string">&quot;以 app-store 方式打包并上传到 iTunes Connect&quot;</span></span><br><span class="line">  <span class="attr">lane</span> :<span class="string">release do</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">puts</span> <span class="string">&quot;自动生成 Provisioning Profiles 文件&quot;</span></span><br><span class="line">    <span class="attr">sigh(</span></span><br><span class="line"><span class="comment">      # 指定输出的文件夹地址</span></span><br><span class="line">      <span class="attr">output_path</span>: <span class="string">&quot;./archive/sign&quot;</span></span><br><span class="line">    <span class="attr">)</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">puts</span> <span class="string">&quot;以 app-store 方式打包&quot;</span></span><br><span class="line">    <span class="attr">gym(</span></span><br><span class="line"><span class="comment">      # 指定打包所使用的输出方式 (可选: app-store, package, ad-hoc, enterprise, development)</span></span><br><span class="line">      <span class="attr">export_method</span>: <span class="string">&quot;app-store&quot;,</span></span><br><span class="line"><span class="comment">      # 指定项目的 scheme 名称</span></span><br><span class="line">      <span class="attr">scheme</span>: <span class="string">&quot;xxx&quot;,</span></span><br><span class="line"><span class="comment">      # 指定输出的文件夹地址</span></span><br><span class="line">      <span class="attr">output_directory</span>: <span class="string">&quot;./archive/release/&quot; + Time.new.strftime(&quot;%Y-%m-%d-%H:%M:%S&quot;),</span></span><br><span class="line"><span class="comment">      # 指定打包方式 (可选: Release, Debug)</span></span><br><span class="line">      <span class="attr">configuration</span>: <span class="string">&quot;Release&quot;</span></span><br><span class="line">    <span class="attr">)</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">puts</span> <span class="string">&quot;上传 ipa 包到 iTunes Connect&quot;</span></span><br><span class="line">    <span class="attr">deliver(</span></span><br><span class="line"><span class="comment">      # 跳过截图上传</span></span><br><span class="line">      <span class="attr">skip_screenshots</span>: <span class="string">true,</span></span><br><span class="line"><span class="comment">      # 跳过元数据上传</span></span><br><span class="line">      <span class="attr">skip_metadata</span>: <span class="string">true,</span></span><br><span class="line"><span class="comment">      # 跳过审核直接上传</span></span><br><span class="line">      <span class="attr">force</span>: <span class="string">true</span></span><br><span class="line">    <span class="attr">)</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">end</span></span><br><span class="line"></span><br><span class="line"><span class="attr">end</span></span><br></pre></td></tr></table></figure><ul><li>需要更改的地方我已经用 <code>xxx</code> 标注出来了，按照说明更改即可，更改完成后保存文件。</li></ul><h2 id="6-开始自动打包并发布"><a href="#6-开始自动打包并发布" class="headerlink" title="6. 开始自动打包并发布"></a>6. 开始自动打包并发布</h2><ul><li><p>打开终端，<code>cd</code> 到你项目工程的根目录（<code>xcodeproj</code> 的同级目录）。</p></li><li><p>输入以下命令，即可开始自动打包并上传到 <code>蒲公英</code> 。</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fastlane beta</span><br></pre></td></tr></table></figure><ul><li>输入以下命令，即可开始自动打包并上传到 <code>iTunes Connect</code> 。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fastlane release</span><br></pre></td></tr></table></figure><ul><li><p>打包的 <code>.ipa</code> 包和 <code>dSYM</code> 文件，以及生成的 <code>Provisioning Profiles</code> 都在工程目录下的 <code>archive</code> 文件夹内，看上面的输出地址就知道了。</p></li><li><p>最后出现一个 <code>successfully 🎉</code> 就表示成功了，有错误终端也会有提示，按照提示继续修改配置就行了。</p></li></ul><blockquote><p><code>Fastlane</code> 还能实现很多自动化的功能，感兴趣的自己去了解一下吧，这里有篇文章写的很全面可以看一下： <a href="https://whlsxl.github.io/fastlane1/">小团队的自动化发布－Fastlane带来的全自动化发布</a> 。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Fastlane&lt;/code&gt; 是一个完全开源的项目，是一款为 &lt;code&gt;iOS&lt;/code&gt; 和 &lt;code&gt;Android&lt;/code&gt; 开发者提供的自动化构建工具，它可以帮助开发者将 &lt;code&gt;App&lt;/code&gt; 打包、签名、测试、发布、信息整理、提交 &lt;code&gt;App Store&lt;/code&gt; 等工作完整的连接起来，实现完全自动化的工作流，如果使用得当，可以显著的提高开发者的开发效率，这是 &lt;a href=&quot;https://github.com/fastlane/fastlane&quot;&gt;GitHub 地址&lt;/a&gt; 和 &lt;a href=&quot;https://docs.fastlane.tools/&quot;&gt;官方文档&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="iOS 开发" scheme="https://karise.cn/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS 开发" scheme="https://karise.cn/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
    <category term="Fastlane" scheme="https://karise.cn/tags/Fastlane/"/>
    
    <category term="持续集成" scheme="https://karise.cn/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    <category term="自动打包" scheme="https://karise.cn/tags/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
</feed>
